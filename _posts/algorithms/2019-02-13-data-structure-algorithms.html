---
layout: post
title: 数据结构与算法
author: zrg
comments: false
description: 简单介绍数据结构和算法，以代码示例的方式加以解释和说明。
categories:
- algorithms
tags:
- Data-Structure
- Algorithms
photos:
---

<div id="outline-container-org8961a9d" class="outline-2">
<h2 id="org8961a9d">数据结构和算法目录</h2>
<div class="outline-text-2" id="text-org8961a9d">
<pre class="example">
首先明确一点：程序=数据结构+算法
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> 数据结构和算法表</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">线性结构</th>
<th scope="col" class="org-left">树</th>
<th scope="col" class="org-left">堆</th>
<th scope="col" class="org-left">图</th>
<th scope="col" class="org-left">排序算法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">数组、单链表和双链表</td>
<td class="org-left">二叉查找树</td>
<td class="org-left">二叉堆</td>
<td class="org-left">图的理论基础</td>
<td class="org-left">冒泡排序</td>
</tr>

<tr>
<td class="org-left">Linux内核中双向链表的经典实现</td>
<td class="org-left">AVL树</td>
<td class="org-left">左倾堆</td>
<td class="org-left">无向图</td>
<td class="org-left">快速排序</td>
</tr>

<tr>
<td class="org-left">栈</td>
<td class="org-left">伸展树</td>
<td class="org-left">斜堆</td>
<td class="org-left">有向图</td>
<td class="org-left">插入排序</td>
</tr>

<tr>
<td class="org-left">队列</td>
<td class="org-left">红黑树</td>
<td class="org-left">二项堆</td>
<td class="org-left">深度优先搜索和广度优先搜索</td>
<td class="org-left">希尔排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">哈夫曼树</td>
<td class="org-left">斐波那契堆</td>
<td class="org-left">拓扑排序</td>
<td class="org-left">选择排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">Kruskal算法</td>
<td class="org-left">堆排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Prim算法</td>
<td class="org-left">归并排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Dijkstra算法</td>
<td class="org-left">桶排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">基数排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org66f1579" class="outline-2">
<h2 id="org66f1579">线性结构</h2>
<div class="outline-text-2" id="text-org66f1579">
<pre class="example">
常用的线性结构有：线性表，栈，队列，循环队列，数组。
</pre>

<ul class="org-ul">
<li>线性表：是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。
<ul class="org-ul">
<li>顺序表：是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。</li>
<li>链表（Linked list）
<ul class="org-ul">
<li>单链表：它由节点组成，每个节点都包含下一个节点的指针。
<ul class="org-ul">
<li>单链表分为：
<ul class="org-ul">
<li>动态单链表</li>
<li>静态单链表</li>
</ul></li>
<li><p>
单链表操作图示
<img src="{{site.url}}/assets/images/linked-list-01.jpg" alt="linked-list-01.jpg" />
</p>
<pre class="example">
表头为空，表头的后继节点是"节点10"，"节点10"的后继节点是"节点20"。
</pre>

<p>
<b>删除节点</b>
<img src="{{site.url}}/assets/images/linked-list-02.jpg" alt="linked-list-02.jpg" />
<b>添加节点</b>
<img src="{{site.url}}/assets/images/linked-list-03.jpg" alt="linked-list-03.jpg" />
</p></li>
<li>单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</li>
</ul></li>
<li>双链表：它也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。
<ul class="org-ul">
<li><p>
双链表操作图示
<img src="{{site.url}}/assets/images/linked-list-04.jpg" alt="linked-list-04.jpg" />
</p>
<pre class="example">
表头为空，表头的后继节点为"节点10"(数据为10的节点)；"节点10"的后继节点是"节点20"(数据为10的节点)，"节点20"的前继节点是"节点10"；"节点20"的后继节点是"节点30"，"节点30"的前继节点是"节点20"；...；末尾节点的后继节点是表头。
</pre>

<p>
<b>删除节点</b>
<img src="{{site.url}}/assets/images/linked-list-05.jpg" alt="linked-list-05.jpg" />
<b>添加节点</b>
<img src="{{site.url}}/assets/images/linked-list-06.jpg" alt="linked-list-06.jpg" />
</p></li>
<li>代码实现
<ul class="org-ul">
<li><p>
Java
</p>
<div class="org-src-container">
<pre class="src src-java" id="org0ad7128"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;"> * Java &#23454;&#29616;&#30340;&#21452;&#21521;&#38142;&#34920;&#12290; </span>
<span style="color: #E6DB74;"> * &#27880;&#65306;java&#33258;&#24102;&#30340;&#38598;&#21512;&#21253;&#20013;&#26377;&#23454;&#29616;&#21452;&#21521;&#38142;&#34920;&#65292;&#36335;&#24452;&#26159;:java.util.LinkedList</span>
<span style="color: #E6DB74;"> */</span>
<span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">DoubleLink</span>&lt;<span style="color: #66D9EF;">T</span>&gt;
</pre>
</div></li>
</ul></li>
</ul></li>
<li>循环链表
<ul class="org-ul">
<li>单循环链表</li>
<li>双循环链表</li>
</ul></li>
</ul></li>
</ul></li>
<li>栈（stack）：是计算机科学中一种特殊的串列形式的抽象数据类型，按照后进先出（LIFO, Last In First Out）的原理运作。其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。</li>
<li>队列：又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</li>
<li>数组：在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。
<img src="{{site.url}}/assets/images/array-data-structure-01.jpg" alt="array-data-structure-01.jpg" />
<ul class="org-ul">
<li>数组的特点是：数据的元素在上下界内是连续的；随机访问速度快。</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9620dcf" class="outline-2">
<h2 id="org9620dcf">树</h2>
<div class="outline-text-2" id="text-org9620dcf">
</div>
<div id="outline-container-org9bfac9f" class="outline-3">
<h3 id="org9bfac9f">二叉树</h3>
</div>
<div id="outline-container-orgbe67ab6" class="outline-3">
<h3 id="orgbe67ab6">AVL 树</h3>
</div>
<div id="outline-container-org1a4cf54" class="outline-3">
<h3 id="org1a4cf54">伸展树</h3>
</div>
<div id="outline-container-orgd4681b8" class="outline-3">
<h3 id="orgd4681b8">红黑树</h3>
</div>
<div id="outline-container-org63a9384" class="outline-3">
<h3 id="org63a9384">哈夫曼树</h3>
</div>
</div>
<div id="outline-container-org01377f4" class="outline-2">
<h2 id="org01377f4">堆</h2>
</div>
<div id="outline-container-org2cca4d3" class="outline-2">
<h2 id="org2cca4d3">图</h2>
</div>
<div id="outline-container-org8f3daef" class="outline-2">
<h2 id="org8f3daef">排序算法</h2>
<div class="outline-text-2" id="text-org8f3daef">
</div>
<div id="outline-container-org68f7db8" class="outline-3">
<h3 id="org68f7db8">冒泡排序(BubbleSort)</h3>
<div class="outline-text-3" id="text-org68f7db8">
</div>
<div id="outline-container-org9caa6b9" class="outline-4">
<h4 id="org9caa6b9">介绍(Introduction)</h4>
<div class="outline-text-4" id="text-org9caa6b9">
<p>
<b>en</b>
</p>
<pre class="example">
Bubblesort is a popular,but inefficient,sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order.
</pre>

<p>
<b>cn</b>
</p>
<pre class="example">
冒泡排序是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，
则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复
此操作，直到整个数列都有序为止！
</pre>
</div>
</div>
<div id="outline-container-orgdcebedb" class="outline-4">
<h4 id="orgdcebedb">伪代码(pseudo code)</h4>
<div class="outline-text-4" id="text-orgdcebedb">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>pseudo code</label><pre class="src src-emacs-lisp">for i = 1 to A.length - 1
    for j = A:length downto i + 1
        if A[j] &lt; A[j-1]   
            exchange A[j] with A[j - 1]
</pre>
</div>
</div>
</div>
<div id="outline-container-orga44b371" class="outline-4">
<h4 id="orga44b371">时间复杂度和稳定性</h4>
<div class="outline-text-4" id="text-orga44b371">
<pre class="example">
冒泡排序的时间复杂度是O(N2)。
假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度是O(N2)。
</pre>


<pre class="example">
冒泡排序是稳定的算法，它满足稳定算法的定义。
算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！
</pre>
</div>
</div>
<div id="outline-container-org59867b0" class="outline-4">
<h4 id="org59867b0">实现(realization)</h4>
<div class="outline-text-4" id="text-org59867b0">
<p>
<b>C</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>C</label><pre class="src src-C"><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>,<span style="color: #FD971F;">j</span>;
<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">flag</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#26631;&#35760;</span>
<span style="color: #F92672;">for</span> (i=n-1; i&gt;0; i--)
{
    flag = 0; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21021;&#22987;&#21270;&#26631;&#35760;&#20026;0</span>
    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#23558;a[0...i]&#20013;&#26368;&#22823;&#30340;&#25968;&#25454;&#25918;&#22312;&#26411;&#23614;</span>
    <span style="color: #F92672;">for</span> (j=0; j&lt;i; j++)
    {
        <span style="color: #F92672;">if</span> (a[j] &gt; a[j+1])
        {
            swap(a[j], a[j+1]);
            flag = 1;    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#33509;&#21457;&#29983;&#20132;&#25442;&#65292;&#21017;&#35774;&#26631;&#35760;&#20026;1</span>
        }
    }
    <span style="color: #F92672;">if</span> (flag==0)
        <span style="color: #F92672;">break</span>;<span style="color: #75715E;">// </span><span style="color: #75715E;">&#33509;&#27809;&#21457;&#29983;&#20132;&#25442;&#65292;&#21017;&#35828;&#26126;&#25968;&#21015;&#24050;&#26377;&#24207;&#12290;</span>
} 
</pre>
</div>

<p>
<b>C#</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>C#</label><pre class="src src-emacs-lisp">//Core code.
for (int i = 0<span style="color: #75715E;">; </span><span style="color: #75715E;">i &lt; arrInt.Length - 1; i++)</span>
{
    for (int j = 1<span style="color: #75715E;">; </span><span style="color: #75715E;">j &lt; arrInt.Length - i; j++)</span>
    {
        if (arrInt[j] &lt; arrInt[j - 1])
        {
            //&#20132;&#25442;&#20540;
            int temp = arrInt[j]<span style="color: #75715E;">;</span>
            arrInt[j] = arrInt[j - 1]<span style="color: #75715E;">;</span>
            arrInt[j - 1] = temp<span style="color: #75715E;">;</span>
        }
    }
}
</pre>
</div>

<p>
<b>Java</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Java</label><pre class="src src-java"><span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">BubbleSort</span>(<span style="color: #66D9EF;">int</span>[] <span style="color: #FD971F;">arr</span>,<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">num</span>) {
    <span style="color: #F92672;">for</span> (<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span> = 0; i &lt; arr.<span style="color: #66D9EF;">length</span>; i++) {
            <span style="color: #F92672;">for</span> (<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">j</span> = num-1; j &gt;i; j--) {
                    <span style="color: #F92672;">if</span> (arr[i]&gt;arr[j]) {
                            <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">temp</span>=arr[i];
                            arr[i]=arr[j];
                            arr[j]=temp;
                    }
            }
    }
    <span style="color: #F92672;">for</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">k</span>=0;k&lt;<span style="color: #66D9EF;">num</span>;k++){
            System.out.print(arr[k]+<span style="color: #E6DB74;">" "</span>);
    }
}
</pre>
</div>

<p>
<b>PHP</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>PHP</label><pre class="src src-shell"><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">BubbleSort</span>($<span style="color: #FD971F;">arr</span>){
        <span style="color: #F92672;">for</span>($<span style="color: #FD971F;">i</span>=0;$<span style="color: #FD971F;">i</span>&lt;count($<span style="color: #FD971F;">arr</span>);$<span style="color: #FD971F;">i</span>++){
                <span style="color: #F92672;">for</span>($<span style="color: #FD971F;">j</span>=0;$<span style="color: #FD971F;">j</span>&lt;$<span style="color: #FD971F;">i</span>;$<span style="color: #FD971F;">j</span>++){
                        <span style="color: #F92672;">if</span>($<span style="color: #FD971F;">arr</span>[$<span style="color: #FD971F;">i</span>]&gt;$<span style="color: #FD971F;">arr</span>[$<span style="color: #FD971F;">j</span>]){
                                $<span style="color: #FD971F;">temp</span> = $<span style="color: #FD971F;">arr</span>[$<span style="color: #FD971F;">i</span>];
                                $<span style="color: #FD971F;">arr</span>[$<span style="color: #FD971F;">i</span>] = $<span style="color: #FD971F;">arr</span>[$<span style="color: #FD971F;">j</span>];
                                $<span style="color: #FD971F;">arr</span>[$<span style="color: #FD971F;">j</span>] = $<span style="color: #FD971F;">temp</span>;
                        }
                }
        }
        <span style="color: #F92672;">foreach</span>($<span style="color: #FD971F;">arr</span> as $<span style="color: #FD971F;">value</span>){
                <span style="color: #F92672;">echo</span> $<span style="color: #FD971F;">value</span>.<span style="color: #E6DB74;">" "</span>;
        }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org331cef0" class="outline-3">
<h3 id="org331cef0">快速排序(QuickSort)</h3>
<div class="outline-text-3" id="text-org331cef0">
</div>
<div id="outline-container-orge78b31f" class="outline-4">
<h4 id="orge78b31f">介绍(Introduction)</h4>
<div class="outline-text-4" id="text-orge78b31f">
<p>
<b>cn</b>
</p>
<pre class="example">
快速排序(Quick Sort)使用分治法策略。
基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外
一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此
达到整个数据变成有序序列。
</pre>


<pre class="example">
快速排序流程：
(1) 从数列中挑出一个基准值。
(2) 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。
(3) 递归地把"基准值前面的子数列"和"基准值后面的子数列"进行排序。
</pre>
</div>
</div>
<div id="outline-container-org5ce27cc" class="outline-4">
<h4 id="org5ce27cc">伪代码(pseudo code)</h4>
</div>
<div id="outline-container-org8937cf9" class="outline-4">
<h4 id="org8937cf9">时间复杂度和稳定</h4>
<div class="outline-text-4" id="text-org8937cf9">
<pre class="example">
快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。 
这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。
(01) 为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。
(02) 为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。
</pre>


<pre class="example">
快速排序是不稳定的算法，它不满足稳定算法的定义。
</pre>
</div>
</div>
<div id="outline-container-orge3a6908" class="outline-4">
<h4 id="orge3a6908">实现(realization)</h4>
<div class="outline-text-4" id="text-orge3a6908">
<p>
<b>C</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #E6DB74;">/**</span>
<span style="color: #E6DB74;">* arr -- &#24453;&#25490;&#24207;&#30340;&#25968;&#32452;</span>
<span style="color: #E6DB74;">* left -- &#25968;&#32452;&#30340;&#24038;&#36793;&#30028;</span>
<span style="color: #E6DB74;">* right -- &#25968;&#32452;&#30340;&#21491;&#36793;&#30028;</span>
<span style="color: #E6DB74;">*/</span>
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">quick_sort</span>(<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">arr</span>[],<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">left</span>,<span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">right</span>){
    <span style="color: #F92672;">if</span>(left &lt; right){
            <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span>,<span style="color: #FD971F;">j</span>,<span style="color: #FD971F;">k</span>;
            i = left;
            j = right;
            k = arr[i];
            <span style="color: #F92672;">while</span>(i &lt; j){
                    <span style="color: #F92672;">while</span>(i &lt; j &amp;&amp; arr[j] &gt; k){
                            j--; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#20174;&#21491;&#24448;&#24038;&#25214;&#19968;&#20010;&#23567;&#20110; k &#30340;&#25968;</span>
                    }
                    <span style="color: #F92672;">if</span>(i &lt; j){
                            arr[i++] = arr[j];
                    }
                    <span style="color: #F92672;">while</span>(i&lt;j &amp;&amp; arr[i] &lt; k){
                            i++; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#20174;&#24038;&#24448;&#21491;&#25214;&#31532;&#19968;&#20010;&#22823;&#20110; k &#30340;&#25968;</span>
                    }
            }
            arr[i] = k;
            quick_sort(arr,left,i-1);
            quick_sort(arr,i+1,right);
    }
}
</pre>
</div>
<p>
<b>Java</b>
</p>
<div class="org-src-container">
<pre class="src src-java">
</pre>
</div>
<p>
<b>PHP</b>
</p>
<div class="org-src-container">
<pre class="src src-shell">
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc1d4b77" class="outline-3">
<h3 id="orgc1d4b77">插入排序(InsertSort)</h3>
<div class="outline-text-3" id="text-orgc1d4b77">
</div>
<div id="outline-container-org9bbd847" class="outline-4">
<h4 id="org9bbd847">介绍(Instoduction)</h4>
</div>
<div id="outline-container-org12c91e6" class="outline-4">
<h4 id="org12c91e6">伪代码(pseudo code)</h4>
<div class="outline-text-4" id="text-org12c91e6">
<div class="org-src-container">
<pre class="src src-emacs-lisp">for j=2 to A.length
    key=A[j]<span style="color: #75715E;">;</span>
    //Insert A[j] into the sorted sequence A[1..j-1]
    i=j-1
    while i&gt;0 and A[i]&gt;key
         A[i+1]=A[i]
         i=i-1
    A[i+1]=key
</pre>
</div>
</div>
</div>
<div id="outline-container-orgecebd23" class="outline-4">
<h4 id="orgecebd23">实现(realization)</h4>
<div class="outline-text-4" id="text-orgecebd23">
<pre class="example">

</pre>
</div>
</div>
<div id="outline-container-org1095f23" class="outline-4">
<h4 id="org1095f23">分而治之(divideand-conquer)</h4>
<div class="outline-text-4" id="text-org1095f23">
<div class="org-src-container">
<pre class="src src-emacs-lisp">
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf65ca3f" class="outline-3">
<h3 id="orgf65ca3f">选择排序</h3>
</div>
<div id="outline-container-org2e73800" class="outline-3">
<h3 id="org2e73800">希尔排序</h3>
</div>
<div id="outline-container-orgf7a5b53" class="outline-3">
<h3 id="orgf7a5b53">归并排序</h3>
</div>
<div id="outline-container-orga1e3922" class="outline-3">
<h3 id="orga1e3922">基数排序</h3>
</div>
<div id="outline-container-org1340b5e" class="outline-3">
<h3 id="org1340b5e">堆排序</h3>
</div>
</div>
<div id="outline-container-org789b68b" class="outline-2">
<h2 id="org789b68b">参考资料</h2>
<div class="outline-text-2" id="text-org789b68b">
<ul class="org-ul">
<li><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表-维基百科</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3603935.html">数据结构与算法系列 目录</a></li>
</ul>
</div>
</div>
