---
layout: post
title: 数据结构与算法
author: zrg
comments: false
description: 简单介绍数据结构和算法，以代码示例的方式加以解释和说明。
categories:
- algorithms
tags:
- Data-Structure
- Algorithms
photos:
---

<div id="outline-container-org875c3f1" class="outline-2">
<h2 id="org875c3f1"><span class="section-number-2">1</span> 算法概述</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org576a530" class="outline-3">
<h3 id="org576a530"><span class="section-number-3">1.1</span> 什么是算法？</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>通俗的讲，算法是指解决问题的一种方法或一个过程。更严格地讲，算法是右若干条指令组成的有穷序列。</li>
<li>程序与算法不同，程序是算法用某种程序设计语言的具体实现。</li>
</ul>
</div>
</div>
<div id="outline-container-org77e9f67" class="outline-3">
<h3 id="org77e9f67"><span class="section-number-3">1.2</span> 算法的复杂性</h3>
<div class="outline-text-3" id="text-1-2">
<p>
算法复杂性的高低体现在运行该算法所需要的计算机资源的多少上。
</p>
</div>
</div>
</div>
<div id="outline-container-org9d01dc5" class="outline-2">
<h2 id="org9d01dc5"><span class="section-number-2">2</span> 数据结构和算法目录</h2>
<div class="outline-text-2" id="text-2">
<pre class="example">
首先明确一点：程序=数据结构+算法
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> 数据结构和算法表</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">线性结构</th>
<th scope="col" class="org-left">树</th>
<th scope="col" class="org-left">堆</th>
<th scope="col" class="org-left">图</th>
<th scope="col" class="org-left">排序算法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">数组、单链表和双链表</td>
<td class="org-left">二叉查找树</td>
<td class="org-left">二叉堆</td>
<td class="org-left">图的理论基础</td>
<td class="org-left">冒泡排序</td>
</tr>

<tr>
<td class="org-left">Linux内核中双向链表的经典实现</td>
<td class="org-left">AVL树</td>
<td class="org-left">左倾堆</td>
<td class="org-left">无向图</td>
<td class="org-left">快速排序</td>
</tr>

<tr>
<td class="org-left">栈</td>
<td class="org-left">伸展树</td>
<td class="org-left">斜堆</td>
<td class="org-left">有向图</td>
<td class="org-left">插入排序</td>
</tr>

<tr>
<td class="org-left">队列</td>
<td class="org-left">红黑树</td>
<td class="org-left">二项堆</td>
<td class="org-left">深度优先搜索和广度优先搜索</td>
<td class="org-left">希尔排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">哈夫曼树</td>
<td class="org-left">斐波那契堆</td>
<td class="org-left">拓扑排序</td>
<td class="org-left">选择排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">Kruskal算法</td>
<td class="org-left">堆排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Prim算法</td>
<td class="org-left">归并排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Dijkstra算法</td>
<td class="org-left">桶排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">基数排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org66f1579" class="outline-2">
<h2 id="org66f1579"><span class="section-number-2">3</span> 线性结构</h2>
<div class="outline-text-2" id="text-3">
<pre class="example">
常用的线性结构有：线性表，栈，队列，循环队列，数组。
</pre>

<ul class="org-ul">
<li>线性表：是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。
<ul class="org-ul">
<li>顺序表：是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。</li>
<li>链表（Linked list）
<ul class="org-ul">
<li>单链表：它由节点组成，每个节点都包含下一个节点的指针。
<ul class="org-ul">
<li>单链表分为：
<ul class="org-ul">
<li>动态单链表</li>
<li>静态单链表</li>
</ul></li>
<li><p>
单链表操作图示
<img src="{{site.url}}/assets/images/linked-list-01.jpg" alt="linked-list-01.jpg" />
</p>
<pre class="example">
表头为空，表头的后继节点是"节点10"，"节点10"的后继节点是"节点20"。
</pre>

<p>
<b>删除节点</b>
<img src="{{site.url}}/assets/images/linked-list-02.jpg" alt="linked-list-02.jpg" />
<b>添加节点</b>
<img src="{{site.url}}/assets/images/linked-list-03.jpg" alt="linked-list-03.jpg" />
</p></li>
<li>单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</li>
</ul></li>
<li>双链表：它也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。
<ul class="org-ul">
<li><p>
双链表操作图示
<img src="{{site.url}}/assets/images/linked-list-04.jpg" alt="linked-list-04.jpg" />
</p>
<pre class="example">
表头为空，表头的后继节点为"节点10"(数据为10的节点)；"节点10"的后继节点是"节点20"(数据为10的节点)，"节点20"的前继节点是"节点10"；"节点20"的后继节点是"节点30"，"节点30"的前继节点是"节点20"；...；末尾节点的后继节点是表头。
</pre>

<p>
<b>删除节点</b>
<img src="{{site.url}}/assets/images/linked-list-05.jpg" alt="linked-list-05.jpg" />
<b>添加节点</b>
<img src="{{site.url}}/assets/images/linked-list-06.jpg" alt="linked-list-06.jpg" />
</p></li>
<li>代码实现
<ul class="org-ul">
<li><p>
Java
</p>
<div class="org-src-container">
<pre class="src src-java" id="org0ad7128"><span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;"> * Java &#23454;&#29616;&#30340;&#21452;&#21521;&#38142;&#34920;&#12290; </span>
<span style="color: #CDC673;"> * &#27880;&#65306;java&#33258;&#24102;&#30340;&#38598;&#21512;&#21253;&#20013;&#26377;&#23454;&#29616;&#21452;&#21521;&#38142;&#34920;&#65292;&#36335;&#24452;&#26159;:java.util.LinkedList</span>
<span style="color: #CDC673;"> */</span>
<span style="color: #FF1493;">public</span> <span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">DoubleLink</span>&lt;<span style="color: #5FD7FF;">T</span>&gt;
</pre>
</div></li>
</ul></li>
</ul></li>
<li>循环链表
<ul class="org-ul">
<li>单循环链表</li>
<li>双循环链表</li>
</ul></li>
</ul></li>
</ul></li>
<li>栈（stack）：是计算机科学中一种特殊的串列形式的抽象数据类型，按照后进先出（LIFO, Last In First Out）的原理运作。其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。</li>
<li>队列：又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</li>
<li>数组：在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。
<img src="{{site.url}}/assets/images/array-data-structure-01.jpg" alt="array-data-structure-01.jpg" />
<ul class="org-ul">
<li>数组的特点是：数据的元素在上下界内是连续的；随机访问速度快。</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9620dcf" class="outline-2">
<h2 id="org9620dcf"><span class="section-number-2">4</span> 树</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org9bfac9f" class="outline-3">
<h3 id="org9bfac9f"><span class="section-number-3">4.1</span> 二叉树</h3>
</div>
<div id="outline-container-orgbe67ab6" class="outline-3">
<h3 id="orgbe67ab6"><span class="section-number-3">4.2</span> AVL 树</h3>
</div>
<div id="outline-container-org1a4cf54" class="outline-3">
<h3 id="org1a4cf54"><span class="section-number-3">4.3</span> 伸展树</h3>
</div>
<div id="outline-container-orgd4681b8" class="outline-3">
<h3 id="orgd4681b8"><span class="section-number-3">4.4</span> 红黑树</h3>
</div>
<div id="outline-container-org63a9384" class="outline-3">
<h3 id="org63a9384"><span class="section-number-3">4.5</span> 哈夫曼树</h3>
</div>
</div>
<div id="outline-container-org01377f4" class="outline-2">
<h2 id="org01377f4"><span class="section-number-2">5</span> 堆</h2>
</div>
<div id="outline-container-org2cca4d3" class="outline-2">
<h2 id="org2cca4d3"><span class="section-number-2">6</span> 图</h2>
</div>
<div id="outline-container-org8f3daef" class="outline-2">
<h2 id="org8f3daef"><span class="section-number-2">7</span> 排序算法</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org68f7db8" class="outline-3">
<h3 id="org68f7db8"><span class="section-number-3">7.1</span> 冒泡排序(BubbleSort)</h3>
<div class="outline-text-3" id="text-7-1">
</div>
<div id="outline-container-org57df710" class="outline-4">
<h4 id="org57df710"><span class="section-number-4">7.1.1</span> 介绍(Introduction)</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
<b>en</b>
</p>
<pre class="example">
Bubblesort is a popular,but inefficient,sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order.
</pre>

<p>
<b>cn</b>
</p>
<pre class="example">
冒泡排序是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，
则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复
此操作，直到整个数列都有序为止！
</pre>
</div>
</div>
<div id="outline-container-org8c3a4fd" class="outline-4">
<h4 id="org8c3a4fd"><span class="section-number-4">7.1.2</span> 伪代码(pseudo code)</h4>
<div class="outline-text-4" id="text-7-1-2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>pseudo code</label><pre class="src src-emacs-lisp">for i = 1 to A.length - 1
    for j = A:length downto i + 1
        if A[j] &lt; A[j-1]   
            exchange A[j] with A[j - 1]
</pre>
</div>
</div>
</div>
<div id="outline-container-orga44b371" class="outline-4">
<h4 id="orga44b371"><span class="section-number-4">7.1.3</span> 时间复杂度和稳定性</h4>
<div class="outline-text-4" id="text-7-1-3">
<pre class="example">
冒泡排序的时间复杂度是O(N2)。
假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度是O(N2)。
</pre>


<pre class="example">
冒泡排序是稳定的算法，它满足稳定算法的定义。
算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！
</pre>
</div>
</div>
<div id="outline-container-org5048019" class="outline-4">
<h4 id="org5048019"><span class="section-number-4">7.1.4</span> 实现(realization)</h4>
<div class="outline-text-4" id="text-7-1-4">
<p>
<b>C</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>C</label><pre class="src src-C"><span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>,<span style="color: #FF8C00;">j</span>;
<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">flag</span>; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#26631;&#35760;</span>
<span style="color: #FF1493;">for</span> (i=n-1; i&gt;0; i--)
{
    flag = 0; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#21021;&#22987;&#21270;&#26631;&#35760;&#20026;0</span>
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#23558;a[0...i]&#20013;&#26368;&#22823;&#30340;&#25968;&#25454;&#25918;&#22312;&#26411;&#23614;</span>
    <span style="color: #FF1493;">for</span> (j=0; j&lt;i; j++)
    {
        <span style="color: #FF1493;">if</span> (a[j] &gt; a[j+1])
        {
            swap(a[j], a[j+1]);
            flag = 1;    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#33509;&#21457;&#29983;&#20132;&#25442;&#65292;&#21017;&#35774;&#26631;&#35760;&#20026;1</span>
        }
    }
    <span style="color: #FF1493;">if</span> (flag==0)
        <span style="color: #FF1493;">break</span>;<span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#33509;&#27809;&#21457;&#29983;&#20132;&#25442;&#65292;&#21017;&#35828;&#26126;&#25968;&#21015;&#24050;&#26377;&#24207;&#12290;</span>
} 
</pre>
</div>

<p>
<b>C#</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>C#</label><pre class="src src-emacs-lisp">//Core code.
for (int i = 0<span style="color: #8B8878;">; </span><span style="color: #8B8878;">i &lt; arrInt.Length - 1; i++)</span>
{
    for (int j = 1<span style="color: #8B8878;">; </span><span style="color: #8B8878;">j &lt; arrInt.Length - i; j++)</span>
    {
        if (arrInt[j] &lt; arrInt[j - 1])
        {
            //&#20132;&#25442;&#20540;
            int temp = arrInt[j]<span style="color: #8B8878;">;</span>
            arrInt[j] = arrInt[j - 1]<span style="color: #8B8878;">;</span>
            arrInt[j - 1] = temp<span style="color: #8B8878;">;</span>
        }
    }
}
</pre>
</div>

<p>
<b>Java</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Java</label><pre class="src src-java"><span style="color: #FF1493;">public</span> <span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">BubbleSort</span>(<span style="color: #5FD7FF;">int</span>[] <span style="color: #FF8C00;">arr</span>,<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">num</span>) {
    <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span> = 0; i &lt; arr.<span style="color: #5FD7FF;">length</span>; i++) {
            <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">j</span> = num-1; j &gt;i; j--) {
                    <span style="color: #FF1493;">if</span> (arr[i]&gt;arr[j]) {
                            <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">temp</span>=arr[i];
                            arr[i]=arr[j];
                            arr[j]=temp;
                    }
            }
    }
    <span style="color: #FF1493;">for</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">k</span>=0;k&lt;<span style="color: #5FD7FF;">num</span>;k++){
            System.out.print(arr[k]+<span style="color: #CDC673;">" "</span>);
    }
}
</pre>
</div>

<p>
<b>PHP</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>PHP</label><pre class="src src-shell"><span style="color: #FF1493;">function</span> <span style="color: #87D700;">BubbleSort</span>($<span style="color: #FF8C00;">arr</span>){
        <span style="color: #FF1493;">for</span>($<span style="color: #FF8C00;">i</span>=0;$<span style="color: #FF8C00;">i</span>&lt;count($<span style="color: #FF8C00;">arr</span>);$<span style="color: #FF8C00;">i</span>++){
                <span style="color: #FF1493;">for</span>($<span style="color: #FF8C00;">j</span>=0;$<span style="color: #FF8C00;">j</span>&lt;$<span style="color: #FF8C00;">i</span>;$<span style="color: #FF8C00;">j</span>++){
                        <span style="color: #FF1493;">if</span>($<span style="color: #FF8C00;">arr</span>[$<span style="color: #FF8C00;">i</span>]&gt;$<span style="color: #FF8C00;">arr</span>[$<span style="color: #FF8C00;">j</span>]){
                                $<span style="color: #FF8C00;">temp</span> = $<span style="color: #FF8C00;">arr</span>[$<span style="color: #FF8C00;">i</span>];
                                $<span style="color: #FF8C00;">arr</span>[$<span style="color: #FF8C00;">i</span>] = $<span style="color: #FF8C00;">arr</span>[$<span style="color: #FF8C00;">j</span>];
                                $<span style="color: #FF8C00;">arr</span>[$<span style="color: #FF8C00;">j</span>] = $<span style="color: #FF8C00;">temp</span>;
                        }
                }
        }
        <span style="color: #FF1493;">foreach</span>($<span style="color: #FF8C00;">arr</span> as $<span style="color: #FF8C00;">value</span>){
                <span style="color: #FF1493;">echo</span> $<span style="color: #FF8C00;">value</span>.<span style="color: #CDC673;">" "</span>;
        }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org331cef0" class="outline-3">
<h3 id="org331cef0"><span class="section-number-3">7.2</span> 快速排序(QuickSort)</h3>
<div class="outline-text-3" id="text-7-2">
</div>
<div id="outline-container-org9400cb7" class="outline-4">
<h4 id="org9400cb7"><span class="section-number-4">7.2.1</span> 介绍(Introduction)</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
<b>cn</b>
</p>
<pre class="example">
快速排序(Quick Sort)使用分治法策略。
基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外
一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此
达到整个数据变成有序序列。
</pre>


<pre class="example">
快速排序流程：
(1) 从数列中挑出一个基准值。
(2) 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。
(3) 递归地把"基准值前面的子数列"和"基准值后面的子数列"进行排序。
</pre>
</div>
</div>
<div id="outline-container-orga186fb1" class="outline-4">
<h4 id="orga186fb1"><span class="section-number-4">7.2.2</span> 伪代码(pseudo code)</h4>
</div>
<div id="outline-container-org8937cf9" class="outline-4">
<h4 id="org8937cf9"><span class="section-number-4">7.2.3</span> 时间复杂度和稳定</h4>
<div class="outline-text-4" id="text-7-2-3">
<pre class="example">
快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。 
这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。
(01) 为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。
(02) 为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。
</pre>


<pre class="example">
快速排序是不稳定的算法，它不满足稳定算法的定义。
</pre>
</div>
</div>
<div id="outline-container-orgdf9b8f0" class="outline-4">
<h4 id="orgdf9b8f0"><span class="section-number-4">7.2.4</span> 实现(realization)</h4>
<div class="outline-text-4" id="text-7-2-4">
<p>
<b>C</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #CDC673;">/**</span>
<span style="color: #CDC673;">* arr -- &#24453;&#25490;&#24207;&#30340;&#25968;&#32452;</span>
<span style="color: #CDC673;">* left -- &#25968;&#32452;&#30340;&#24038;&#36793;&#30028;</span>
<span style="color: #CDC673;">* right -- &#25968;&#32452;&#30340;&#21491;&#36793;&#30028;</span>
<span style="color: #CDC673;">*/</span>
<span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">quick_sort</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">arr</span>[],<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">left</span>,<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">right</span>){
    <span style="color: #FF1493;">if</span>(left &lt; right){
            <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>,<span style="color: #FF8C00;">j</span>,<span style="color: #FF8C00;">k</span>;
            i = left;
            j = right;
            k = arr[i];
            <span style="color: #FF1493;">while</span>(i &lt; j){
                    <span style="color: #FF1493;">while</span>(i &lt; j &amp;&amp; arr[j] &gt; k){
                            j--; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#20174;&#21491;&#24448;&#24038;&#25214;&#19968;&#20010;&#23567;&#20110; k &#30340;&#25968;</span>
                    }
                    <span style="color: #FF1493;">if</span>(i &lt; j){
                            arr[i++] = arr[j];
                    }
                    <span style="color: #FF1493;">while</span>(i&lt;j &amp;&amp; arr[i] &lt; k){
                            i++; <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#20174;&#24038;&#24448;&#21491;&#25214;&#31532;&#19968;&#20010;&#22823;&#20110; k &#30340;&#25968;</span>
                    }
            }
            arr[i] = k;
            quick_sort(arr,left,i-1);
            quick_sort(arr,i+1,right);
    }
}
</pre>
</div>
<p>
<b>Java</b>
</p>
<div class="org-src-container">
<pre class="src src-java">
</pre>
</div>
<p>
<b>PHP</b>
</p>
<div class="org-src-container">
<pre class="src src-shell">
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc1d4b77" class="outline-3">
<h3 id="orgc1d4b77"><span class="section-number-3">7.3</span> 插入排序(InsertSort)</h3>
<div class="outline-text-3" id="text-7-3">
</div>
<div id="outline-container-org9bbd847" class="outline-4">
<h4 id="org9bbd847"><span class="section-number-4">7.3.1</span> 介绍(Instoduction)</h4>
</div>
<div id="outline-container-org442c658" class="outline-4">
<h4 id="org442c658"><span class="section-number-4">7.3.2</span> 伪代码(pseudo code)</h4>
<div class="outline-text-4" id="text-7-3-2">
<div class="org-src-container">
<pre class="src src-emacs-lisp">for j=2 to A.length
    key=A[j]<span style="color: #8B8878;">;</span>
    //Insert A[j] into the sorted sequence A[1..j-1]
    i=j-1
    while i&gt;0 and A[i]&gt;key
         A[i+1]=A[i]
         i=i-1
    A[i+1]=key
</pre>
</div>
</div>
</div>
<div id="outline-container-orgddfae3f" class="outline-4">
<h4 id="orgddfae3f"><span class="section-number-4">7.3.3</span> 实现(realization)</h4>
<div class="outline-text-4" id="text-7-3-3">
<pre class="example">

</pre>
</div>
</div>
<div id="outline-container-org1095f23" class="outline-4">
<h4 id="org1095f23"><span class="section-number-4">7.3.4</span> 分而治之(divideand-conquer)</h4>
<div class="outline-text-4" id="text-7-3-4">
<div class="org-src-container">
<pre class="src src-emacs-lisp">
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf65ca3f" class="outline-3">
<h3 id="orgf65ca3f"><span class="section-number-3">7.4</span> 选择排序</h3>
</div>
<div id="outline-container-org2e73800" class="outline-3">
<h3 id="org2e73800"><span class="section-number-3">7.5</span> 希尔排序</h3>
</div>
<div id="outline-container-orgf7a5b53" class="outline-3">
<h3 id="orgf7a5b53"><span class="section-number-3">7.6</span> 归并排序</h3>
</div>
<div id="outline-container-orga1e3922" class="outline-3">
<h3 id="orga1e3922"><span class="section-number-3">7.7</span> 基数排序</h3>
</div>
<div id="outline-container-org1340b5e" class="outline-3">
<h3 id="org1340b5e"><span class="section-number-3">7.8</span> 堆排序</h3>
</div>
</div>
<div id="outline-container-org789b68b" class="outline-2">
<h2 id="org789b68b"><span class="section-number-2">8</span> 参考资料</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表-维基百科</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3603935.html">数据结构与算法系列 目录</a></li>
</ul>
</div>
</div>
<div id="outline-container-org8e7ca84" class="outline-2">
<h2 id="org8e7ca84"><span class="section-number-2">9</span> 附录A 伪代码</h2>
<div class="outline-text-2" id="text-9">
<p>
伪代码(Pseudocode)是一种算法描述语言。使用伪代码的目的是为了使被描述的算法可以容易地以任何一种编程语言(C, Java, Pascal)实现。
</p>
</div>
<div id="outline-container-orgb263588" class="outline-3">
<h3 id="orgb263588"><span class="section-number-3">9.1</span> 语法规则</h3>
<div class="outline-text-3" id="text-9-1">
</div>
<div id="outline-container-orgbe92042" class="outline-4">
<h4 id="orgbe92042"><span class="section-number-4">9.1.1</span> 变量的声明</h4>
<div class="outline-text-4" id="text-9-1-1">
<p>
算法中出现的数组、变量可以是以下类型：整数、实数、字符、字符串或指针。
</p>
</div>
</div>
<div id="outline-container-orge21a674" class="outline-4">
<h4 id="orge21a674"><span class="section-number-4">9.1.2</span> 指令的表示</h4>
<div class="outline-text-4" id="text-9-1-2">
<p>
在算法中的某些指令或子任务可以用文字来叙述，例如，”设x是A中的最大项”，这里A是一个数组；或者”将x插入L中”，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。
</p>
</div>
</div>
<div id="outline-container-orgf0e31e8" class="outline-4">
<h4 id="orgf0e31e8"><span class="section-number-4">9.1.3</span> 表达式</h4>
<div class="outline-text-4" id="text-9-1-3">
<p>
算术表达式可以使用通常的算术运算符（+，-，*，/，以及表示幂的^）。逻辑表达式可以使用关系运算符 = 、≠、&lt;、&gt;、≤ 和 ≥，以及逻辑运算符与(and)、或（or）、非（not）。
</p>
</div>
</div>
<div id="outline-container-org254cfbc" class="outline-4">
<h4 id="org254cfbc"><span class="section-number-4">9.1.4</span> 赋值语句</h4>
<div class="outline-text-4" id="text-9-1-4">
<p>
赋值语句是如下形式的语句：a←b。这里a是变量、数组项，b是算术表达式、逻辑表达式或指针表达式。语句的含义是将b的值赋给a。
<br />
变量交换：若a和b都是变量、数组项，那么记号a&lt;-&gt;b 表示a和b的内容进行交换。
</p>
</div>
</div>
<div id="outline-container-org60928a1" class="outline-4">
<h4 id="org60928a1"><span class="section-number-4">9.1.5</span> goto语句</h4>
<div class="outline-text-4" id="text-9-1-5">
<pre class="example">
goto label（goto标号）
</pre>
</div>
</div>
<div id="outline-container-org44cb63e" class="outline-4">
<h4 id="org44cb63e"><span class="section-number-4">9.1.6</span> 分支结构</h4>
<div class="outline-text-4" id="text-9-1-6">
<div class="org-src-container">
<pre class="src src-emacs-lisp">if i=10
    then xxxx
    else xxxx //else &#21644; then &#35201;&#23545;&#40784;

//&#25110;&#32773;
if i=10
    then xxxx //if &#21518;&#38754;&#24517;&#23450;&#36319;&#19978;then&#65292;else&#21518;&#38754;&#19981;&#29992;&#36319;then
    elseif i=9 //elseif &#35201;&#36830;&#22312;&#19968;&#36215;&#20889;
        then xxxx
        yyyy
    else  xxxx //else &#36319;&#22312; elseif &#30340; then &#23545;&#40784;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb8d2ffe" class="outline-4">
<h4 id="orgb8d2ffe"><span class="section-number-4">9.1.7</span> 循环结构</h4>
<div class="outline-text-4" id="text-9-1-7">
<div class="org-src-container">
<pre class="src src-emacs-lisp">// while
while time&lt;10
    do  xxxxx //while&#21518;&#38754;&#24517;&#23450;&#35201;&#32039;&#36319;&#32553;&#36827;&#30340;do
    xxxxx
end

// for
for var init to limit by incr 
        do s
end
// &#36825;&#37324;var&#26159;&#21464;&#37327;&#65292;init&#12289;limit&#21644;incr&#37117;&#26159;&#31639;&#26415;&#34920;&#36798;&#24335;&#65292;&#32780;s&#26159;&#30001;&#19968;&#20010;&#25110;&#22810;&#20010;&#35821;&#21477;&#32452;&#25104;&#30340;&#35821;&#21477;&#20018;&#12290;&#21021;&#22987;&#26102;&#65292;var&#34987;&#36171;&#20104;init&#30340;&#20540;&#12290;&#20551;&#33509;incr&#8805;0&#65292;&#21017;&#21482;&#35201;var&#8804;limit&#65292;&#23601;&#25191;&#34892;s&#24182;&#19988;&#23558;incr&#21152;&#21040;var&#19978;&#12290;&#65288;&#20551;&#33509;incr&lt;0&#65292;&#21017;&#21482;&#35201;var&#8805;limit&#65292;&#23601;&#25191;&#34892;s&#24182;&#19988;&#23558;incr&#21152;&#21040;var&#19978;&#65289;&#12290;incr&#30340;&#31526;&#21495;&#19981;&#33021;&#30001;s&#26469;&#35813;&#25913;&#21464;&#12290;
</pre>
</div>
</div>
</div>
<div id="outline-container-orga635eda" class="outline-4">
<h4 id="orga635eda"><span class="section-number-4">9.1.8</span> 程序的结束</h4>
<div class="outline-text-4" id="text-9-1-8">
<p>
exit语句可以在通常的结束条件满足之前，被用来结束while循环或者for循环的执行。
<br />
return用来指出一个算法执行的终点
</p>
</div>
</div>
<div id="outline-container-org0d3caf1" class="outline-4">
<h4 id="org0d3caf1"><span class="section-number-4">9.1.9</span> 注释风格</h4>
<div class="outline-text-4" id="text-9-1-9">
<p>
算法中的注释被括在 <i>* *</i> 之中。
</p>
</div>
</div>
<div id="outline-container-org69f513f" class="outline-4">
<h4 id="org69f513f"><span class="section-number-4">9.1.10</span> 函数的编写</h4>
<div class="outline-text-4" id="text-9-1-10">
<p>
函数的伪代码格式例子为：search（A，name）， 参数类型可以不给出，但必须在注释中说明。
</p>
</div>
</div>
</div>
<div id="outline-container-org1013c40" class="outline-3">
<h3 id="org1013c40"><span class="section-number-3">9.2</span> 实例</h3>
<div class="outline-text-3" id="text-9-2">
<p>
伪代码：
</p>
<div class="org-src-container">
<pre class="src src-lisp">x &#8592; 0
y &#8592; 0
z &#8592; 0

while x &lt; N
do x &#8592; x + 1
y &#8592; x + y
for t &#8592; 0 to 10
do z &#8592; ( z + x * y ) / 100
repeat
y &#8592; y + 1
z &#8592; z - y
until z &lt; 0
z &#8592; x * y

y &#8592; y / 2
</pre>
</div>

<p>
C 语言代码：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #FF1493;">#inlude</span> &lt;stdio.h&gt;
<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">x</span>, <span style="color: #FF8C00;">y</span>, <span style="color: #FF8C00;">z</span> = 0;
<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">N</span>=10;

<span style="color: #FF1493;">while</span>( z &lt; N )
{
    x++;
    y += x;
  &#12288;<span style="color: #FF1493;">for</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">t</span> = 0; t &lt; 10; t++ )
    {
        z = ( z + x * y ) / 100;
        <span style="color: #FF1493;">do</span> 
        {
          y ++;
          z -= y;
        } <span style="color: #FF1493;">while</span>( z &gt;= 0 );
    }
    z = x * y;
}

y /= 2;
</pre>
</div>
</div>
</div>
</div>
