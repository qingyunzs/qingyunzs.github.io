---
layout: post
title: 数据结构与算法
author: zrg
comments: false
description: 简单介绍数据结构和算法，以代码示例的方式加以解释和说明。
categories:
- algorithms
tags:
- Data-Structure
- Algorithms
photos:
---

<div id="outline-container-orgfb1089b" class="outline-2">
<h2 id="orgfb1089b">数据结构和算法目录</h2>
<div class="outline-text-2" id="text-orgfb1089b">
<pre class="example">
首先明确一点：程序=数据结构+算法
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> 数据结构和算法表</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">线性结构</th>
<th scope="col" class="org-left">树</th>
<th scope="col" class="org-left">堆</th>
<th scope="col" class="org-left">图</th>
<th scope="col" class="org-left">排序算法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">数组、单链表和双链表</td>
<td class="org-left">二叉查找树</td>
<td class="org-left">二叉堆</td>
<td class="org-left">图的理论基础</td>
<td class="org-left">冒泡排序</td>
</tr>

<tr>
<td class="org-left">Linux内核中双向链表的经典实现</td>
<td class="org-left">AVL树</td>
<td class="org-left">左倾堆</td>
<td class="org-left">无向图</td>
<td class="org-left">快速排序</td>
</tr>

<tr>
<td class="org-left">栈</td>
<td class="org-left">伸展树</td>
<td class="org-left">斜堆</td>
<td class="org-left">有向图</td>
<td class="org-left">插入排序</td>
</tr>

<tr>
<td class="org-left">队列</td>
<td class="org-left">红黑树</td>
<td class="org-left">二项堆</td>
<td class="org-left">深度优先搜索和广度优先搜索</td>
<td class="org-left">希尔排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">哈夫曼树</td>
<td class="org-left">斐波那契堆</td>
<td class="org-left">拓扑排序</td>
<td class="org-left">选择排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">Kruskal算法</td>
<td class="org-left">堆排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Prim算法</td>
<td class="org-left">归并排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Dijkstra算法</td>
<td class="org-left">桶排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">基数排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org7f683b0" class="outline-2">
<h2 id="org7f683b0">线性结构</h2>
<div class="outline-text-2" id="text-org7f683b0">
<pre class="example">
常用的线性结构有：线性表，栈，队列，循环队列，数组。
</pre>

<ul class="org-ul">
<li>线性表：是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。
<ul class="org-ul">
<li>顺序表：是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。</li>
<li>链表（Linked list）
<ul class="org-ul">
<li>单链表：它由节点组成，每个节点都包含下一个节点的指针。
<ul class="org-ul">
<li>单链表分为：
<ul class="org-ul">
<li>动态单链表</li>
<li>静态单链表</li>
</ul></li>
<li><p>
单链表操作图示
<img src="{{site.url}}/assets/images/linked-list-01.jpg" alt="linked-list-01.jpg" />
</p>
<pre class="example">
表头为空，表头的后继节点是"节点10"，"节点10"的后继节点是"节点20"。
</pre>

<p>
<b>删除节点</b>
<img src="{{site.url}}/assets/images/linked-list-02.jpg" alt="linked-list-02.jpg" />
<b>添加节点</b>
<img src="{{site.url}}/assets/images/linked-list-03.jpg" alt="linked-list-03.jpg" />
</p></li>
<li>单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</li>
</ul></li>
<li>双链表：它也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。
<ul class="org-ul">
<li><p>
双链表操作图示
<img src="{{site.url}}/assets/images/linked-list-04.jpg" alt="linked-list-04.jpg" />
</p>
<pre class="example">
表头为空，表头的后继节点为"节点10"(数据为10的节点)；"节点10"的后继节点是"节点20"(数据为10的节点)，"节点20"的前继节点是"节点10"；"节点20"的后继节点是"节点30"，"节点30"的前继节点是"节点20"；...；末尾节点的后继节点是表头。
</pre>

<p>
<b>删除节点</b>
<img src="{{site.url}}/assets/images/linked-list-05.jpg" alt="linked-list-05.jpg" />
<b>添加节点</b>
<img src="{{site.url}}/assets/images/linked-list-06.jpg" alt="linked-list-06.jpg" />
</p></li>
<li>代码实现
<ul class="org-ul">
<li><p>
Java
</p>
<div class="org-src-container">
<pre class="src src-java" id="org3dd71ac"><span style="color: #8b2252;">/**</span>
<span style="color: #8b2252;"> * Java &#23454;&#29616;&#30340;&#21452;&#21521;&#38142;&#34920;&#12290; </span>
<span style="color: #8b2252;"> * &#27880;&#65306;java&#33258;&#24102;&#30340;&#38598;&#21512;&#21253;&#20013;&#26377;&#23454;&#29616;&#21452;&#21521;&#38142;&#34920;&#65292;&#36335;&#24452;&#26159;:java.util.LinkedList</span>
<span style="color: #8b2252;"> */</span>
<span style="color: #a020f0;">public</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">DoubleLink</span>&lt;<span style="color: #228b22;">T</span>&gt;
</pre>
</div></li>
</ul></li>
</ul></li>
<li>循环链表
<ul class="org-ul">
<li>单循环链表</li>
<li>双循环链表</li>
</ul></li>
</ul></li>
</ul></li>
<li>栈（stack）：是计算机科学中一种特殊的串列形式的抽象数据类型，按照后进先出（LIFO, Last In First Out）的原理运作。其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。</li>
<li>队列：又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</li>
<li>数组：在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。
<img src="{{site.url}}/assets/images/array-data-structure-01.jpg" alt="array-data-structure-01.jpg" />
<ul class="org-ul">
<li>数组的特点是：数据的元素在上下界内是连续的；随机访问速度快。</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org01c6718" class="outline-2">
<h2 id="org01c6718">树</h2>
<div class="outline-text-2" id="text-org01c6718">
</div>
<div id="outline-container-org380a7b4" class="outline-3">
<h3 id="org380a7b4">二叉树</h3>
</div>
<div id="outline-container-orgb6ebed2" class="outline-3">
<h3 id="orgb6ebed2">AVL 树</h3>
</div>
<div id="outline-container-org017d4ba" class="outline-3">
<h3 id="org017d4ba">伸展树</h3>
</div>
<div id="outline-container-org151ae43" class="outline-3">
<h3 id="org151ae43">红黑树</h3>
</div>
<div id="outline-container-org9e201a7" class="outline-3">
<h3 id="org9e201a7">哈夫曼树</h3>
</div>
</div>
<div id="outline-container-orgc2d81fb" class="outline-2">
<h2 id="orgc2d81fb">堆</h2>
</div>
<div id="outline-container-org55cfb1b" class="outline-2">
<h2 id="org55cfb1b">图</h2>
</div>
<div id="outline-container-org7b880ad" class="outline-2">
<h2 id="org7b880ad">排序算法</h2>
<div class="outline-text-2" id="text-org7b880ad">
</div>
<div id="outline-container-orged4c6bf" class="outline-3">
<h3 id="orged4c6bf">冒泡排序(BubbleSort)</h3>
<div class="outline-text-3" id="text-orged4c6bf">
</div>
<div id="outline-container-org14f48f1" class="outline-4">
<h4 id="org14f48f1">介绍(Introduction)</h4>
<div class="outline-text-4" id="text-org14f48f1">
<p>
<b>en</b>
</p>
<pre class="example">
Bubblesort is a popular,but inefficient,sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order.
</pre>

<p>
<b>cn</b>
</p>
<pre class="example">
冒泡排序是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，
则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复
此操作，直到整个数列都有序为止！
</pre>
</div>
</div>
<div id="outline-container-org66085c9" class="outline-4">
<h4 id="org66085c9">伪代码(pseudo code)</h4>
<div class="outline-text-4" id="text-org66085c9">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>pseudo code</label><pre class="src src-emacs-lisp">for i = 1 to A.length - 1
    for j = A:length downto i + 1
        if A[j] &lt; A[j-1]   
            exchange A[j] with A[j - 1]
</pre>
</div>
</div>
</div>
<div id="outline-container-org9182ad5" class="outline-4">
<h4 id="org9182ad5">时间复杂度和稳定性</h4>
<div class="outline-text-4" id="text-org9182ad5">
<pre class="example">
冒泡排序的时间复杂度是O(N2)。
假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度是O(N2)。
</pre>


<pre class="example">
冒泡排序是稳定的算法，它满足稳定算法的定义。
算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！
</pre>
</div>
</div>
<div id="outline-container-org7c9d32d" class="outline-4">
<h4 id="org7c9d32d">实现(realization)</h4>
<div class="outline-text-4" id="text-org7c9d32d">
<p>
<b>C</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>C</label><pre class="src src-C"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>,<span style="color: #a0522d;">j</span>;
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">flag</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26631;&#35760;</span>
<span style="color: #a020f0;">for</span> (i=n-1; i&gt;0; i--)
{
    flag = 0; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21021;&#22987;&#21270;&#26631;&#35760;&#20026;0</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23558;a[0...i]&#20013;&#26368;&#22823;&#30340;&#25968;&#25454;&#25918;&#22312;&#26411;&#23614;</span>
    <span style="color: #a020f0;">for</span> (j=0; j&lt;i; j++)
    {
        <span style="color: #a020f0;">if</span> (a[j] &gt; a[j+1])
        {
            swap(a[j], a[j+1]);
            flag = 1;    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#33509;&#21457;&#29983;&#20132;&#25442;&#65292;&#21017;&#35774;&#26631;&#35760;&#20026;1</span>
        }
    }
    <span style="color: #a020f0;">if</span> (flag==0)
        <span style="color: #a020f0;">break</span>;<span style="color: #b22222;">// </span><span style="color: #b22222;">&#33509;&#27809;&#21457;&#29983;&#20132;&#25442;&#65292;&#21017;&#35828;&#26126;&#25968;&#21015;&#24050;&#26377;&#24207;&#12290;</span>
} 
</pre>
</div>

<p>
<b>C#</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>C#</label><pre class="src src-emacs-lisp">//Core code.
for (int i = 0<span style="color: #b22222;">; </span><span style="color: #b22222;">i &lt; arrInt.Length - 1; i++)</span>
{
    for (int j = 1<span style="color: #b22222;">; </span><span style="color: #b22222;">j &lt; arrInt.Length - i; j++)</span>
    {
        if (arrInt[j] &lt; arrInt[j - 1])
        {
            //&#20132;&#25442;&#20540;
            int temp = arrInt[j]<span style="color: #b22222;">;</span>
            arrInt[j] = arrInt[j - 1]<span style="color: #b22222;">;</span>
            arrInt[j - 1] = temp<span style="color: #b22222;">;</span>
        }
    }
}
</pre>
</div>

<p>
<b>Java</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Java</label><pre class="src src-java"><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">BubbleSort</span>(<span style="color: #228b22;">int</span>[] <span style="color: #a0522d;">arr</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">num</span>) {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; arr.<span style="color: #228b22;">length</span>; i++) {
            <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span> = num-1; j &gt;i; j--) {
                    <span style="color: #a020f0;">if</span> (arr[i]&gt;arr[j]) {
                            <span style="color: #228b22;">int</span> <span style="color: #a0522d;">temp</span>=arr[i];
                            arr[i]=arr[j];
                            arr[j]=temp;
                    }
            }
    }
    <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">k</span>=0;k&lt;<span style="color: #228b22;">num</span>;k++){
            System.out.print(arr[k]+<span style="color: #8b2252;">" "</span>);
    }
}
</pre>
</div>

<p>
<b>PHP</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>PHP</label><pre class="src src-shell"><span style="color: #a020f0;">function</span> <span style="color: #0000ff;">BubbleSort</span>($<span style="color: #a0522d;">arr</span>){
        <span style="color: #a020f0;">for</span>($<span style="color: #a0522d;">i</span>=0;$<span style="color: #a0522d;">i</span>&lt;count($<span style="color: #a0522d;">arr</span>);$<span style="color: #a0522d;">i</span>++){
                <span style="color: #a020f0;">for</span>($<span style="color: #a0522d;">j</span>=0;$<span style="color: #a0522d;">j</span>&lt;$<span style="color: #a0522d;">i</span>;$<span style="color: #a0522d;">j</span>++){
                        <span style="color: #a020f0;">if</span>($<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">i</span>]&gt;$<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">j</span>]){
                                $<span style="color: #a0522d;">temp</span> = $<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">i</span>];
                                $<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">i</span>] = $<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">j</span>];
                                $<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">j</span>] = $<span style="color: #a0522d;">temp</span>;
                        }
                }
        }
        foreach($<span style="color: #a0522d;">arr</span> as $<span style="color: #a0522d;">value</span>){
                <span style="color: #483d8b;">echo</span> $<span style="color: #a0522d;">value</span>.<span style="color: #8b2252;">" "</span>;
        }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb4cf07c" class="outline-3">
<h3 id="orgb4cf07c">快速排序(QuickSort)</h3>
<div class="outline-text-3" id="text-orgb4cf07c">
</div>
<div id="outline-container-org72e31a9" class="outline-4">
<h4 id="org72e31a9">介绍(Introduction)</h4>
<div class="outline-text-4" id="text-org72e31a9">
<p>
<b>cn</b>
</p>
<pre class="example">
快速排序(Quick Sort)使用分治法策略。
基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外
一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此
达到整个数据变成有序序列。
</pre>


<pre class="example">
快速排序流程：
(1) 从数列中挑出一个基准值。
(2) 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。
(3) 递归地把"基准值前面的子数列"和"基准值后面的子数列"进行排序。
</pre>
</div>
</div>
<div id="outline-container-org0a840e7" class="outline-4">
<h4 id="org0a840e7">伪代码(pseudo code)</h4>
</div>
<div id="outline-container-org8289f83" class="outline-4">
<h4 id="org8289f83">时间复杂度和稳定</h4>
<div class="outline-text-4" id="text-org8289f83">
<pre class="example">
快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。 
这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。
(01) 为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。
(02) 为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。
</pre>


<pre class="example">
快速排序是不稳定的算法，它不满足稳定算法的定义。
</pre>
</div>
</div>
<div id="outline-container-orgf0c2dfa" class="outline-4">
<h4 id="orgf0c2dfa">实现(realization)</h4>
<div class="outline-text-4" id="text-orgf0c2dfa">
<p>
<b>C</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8b2252;">/**</span>
<span style="color: #8b2252;">* arr -- &#24453;&#25490;&#24207;&#30340;&#25968;&#32452;</span>
<span style="color: #8b2252;">* left -- &#25968;&#32452;&#30340;&#24038;&#36793;&#30028;</span>
<span style="color: #8b2252;">* right -- &#25968;&#32452;&#30340;&#21491;&#36793;&#30028;</span>
<span style="color: #8b2252;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">quick_sort</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">arr</span>[],<span style="color: #228b22;">int</span> <span style="color: #a0522d;">left</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">right</span>){
    <span style="color: #a020f0;">if</span>(left &lt; right){
            <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>,<span style="color: #a0522d;">j</span>,<span style="color: #a0522d;">k</span>;
            i = left;
            j = right;
            k = arr[i];
            <span style="color: #a020f0;">while</span>(i &lt; j){
                    <span style="color: #a020f0;">while</span>(i &lt; j &amp;&amp; arr[j] &gt; k){
                            j--; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20174;&#21491;&#24448;&#24038;&#25214;&#19968;&#20010;&#23567;&#20110; k &#30340;&#25968;</span>
                    }
                    <span style="color: #a020f0;">if</span>(i &lt; j){
                            arr[i++] = arr[j];
                    }
                    <span style="color: #a020f0;">while</span>(i&lt;j &amp;&amp; arr[i] &lt; k){
                            i++; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20174;&#24038;&#24448;&#21491;&#25214;&#31532;&#19968;&#20010;&#22823;&#20110; k &#30340;&#25968;</span>
                    }
            }
            arr[i] = k;
            quick_sort(arr,left,i-1);
            quick_sort(arr,i+1,right);
    }
}
</pre>
</div>
<p>
<b>Java</b>
</p>
<div class="org-src-container">
<pre class="src src-java">
</pre>
</div>
<p>
<b>PHP</b>
</p>
<div class="org-src-container">
<pre class="src src-shell">
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7fa6d96" class="outline-3">
<h3 id="org7fa6d96">插入排序(InsertSort)</h3>
<div class="outline-text-3" id="text-org7fa6d96">
</div>
<div id="outline-container-org57717f6" class="outline-4">
<h4 id="org57717f6">介绍(Instoduction)</h4>
</div>
<div id="outline-container-orge0b3403" class="outline-4">
<h4 id="orge0b3403">伪代码(pseudo code)</h4>
<div class="outline-text-4" id="text-orge0b3403">
<div class="org-src-container">
<pre class="src src-emacs-lisp">for j=2 to A.length
    key=A[j]<span style="color: #b22222;">;</span>
    //Insert A[j] into the sorted sequence A[1..j-1]
    i=j-1
    while i&gt;0 and A[i]&gt;key
         A[i+1]=A[i]
         i=i-1
    A[i+1]=key
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd20aa8d" class="outline-4">
<h4 id="orgd20aa8d">实现(realization)</h4>
<div class="outline-text-4" id="text-orgd20aa8d">
<pre class="example">

</pre>
</div>
</div>
<div id="outline-container-orgff596f2" class="outline-4">
<h4 id="orgff596f2">分而治之(divideand-conquer)</h4>
<div class="outline-text-4" id="text-orgff596f2">
<div class="org-src-container">
<pre class="src src-emacs-lisp">
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org9eaced7" class="outline-3">
<h3 id="org9eaced7">选择排序</h3>
</div>
<div id="outline-container-org7ee17ed" class="outline-3">
<h3 id="org7ee17ed">希尔排序</h3>
</div>
<div id="outline-container-orge1fba89" class="outline-3">
<h3 id="orge1fba89">归并排序</h3>
</div>
<div id="outline-container-org3d92621" class="outline-3">
<h3 id="org3d92621">基数排序</h3>
</div>
<div id="outline-container-orgc5d3782" class="outline-3">
<h3 id="orgc5d3782">堆排序</h3>
</div>
</div>
<div id="outline-container-org28e7202" class="outline-2">
<h2 id="org28e7202">参考资料</h2>
<div class="outline-text-2" id="text-org28e7202">
<ul class="org-ul">
<li><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表-维基百科</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3603935.html">数据结构与算法系列 目录</a></li>
</ul>
</div>
</div>
