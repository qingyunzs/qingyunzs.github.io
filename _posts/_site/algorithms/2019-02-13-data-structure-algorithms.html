---
layout: post
title: 数据结构与算法
author: zrg
comments: false
description: 简单介绍数据结构和算法，以代码示例的方式加以解释和说明。
categories:
- algorithms
tags:
- Data-Structure
- Algorithms
photos:
---

<div id="outline-container-org2691066" class="outline-2">
<h2 id="org2691066"><span class="section-number-2">1</span> 数据结构和算法目录</h2>
<div class="outline-text-2" id="text-1">
<pre class="example">
首先明确一点：程序=数据结构+算法

</pre>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> 数据结构和算法表</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">线性结构</th>
<th scope="col" class="org-left">树</th>
<th scope="col" class="org-left">堆</th>
<th scope="col" class="org-left">图</th>
<th scope="col" class="org-left">排序算法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">数组、单链表和双链表</td>
<td class="org-left">二叉查找树</td>
<td class="org-left">二叉堆</td>
<td class="org-left">图的理论基础</td>
<td class="org-left">冒泡排序</td>
</tr>

<tr>
<td class="org-left">Linux内核中双向链表的经典实现</td>
<td class="org-left">AVL树</td>
<td class="org-left">左倾堆</td>
<td class="org-left">无向图</td>
<td class="org-left">快速排序</td>
</tr>

<tr>
<td class="org-left">栈</td>
<td class="org-left">伸展树</td>
<td class="org-left">斜堆</td>
<td class="org-left">有向图</td>
<td class="org-left">插入排序</td>
</tr>

<tr>
<td class="org-left">队列</td>
<td class="org-left">红黑树</td>
<td class="org-left">二项堆</td>
<td class="org-left">深度优先搜索和广度优先搜索</td>
<td class="org-left">希尔排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">哈夫曼树</td>
<td class="org-left">斐波那契堆</td>
<td class="org-left">拓扑排序</td>
<td class="org-left">选择排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">Kruskal算法</td>
<td class="org-left">堆排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Prim算法</td>
<td class="org-left">归并排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Dijkstra算法</td>
<td class="org-left">桶排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">基数排序</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org72bbf86" class="outline-2">
<h2 id="org72bbf86"><span class="section-number-2">2</span> 线性结构</h2>
<div class="outline-text-2" id="text-2">
<pre class="example">
常用的线性结构有：线性表，栈，队列，循环队列，数组。

</pre>
<ul class="org-ul">
<li>线性表：是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。
<ul class="org-ul">
<li>顺序表：是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。</li>
<li>链表（Linked list）
<ul class="org-ul">
<li>单链表：它由节点组成，每个节点都包含下一个节点的指针。
<ul class="org-ul">
<li>单链表分为：
<ul class="org-ul">
<li>动态单链表</li>
<li>静态单链表</li>
</ul></li>
<li><p>
单链表操作图示
<img src="{{site.url}}/assets/images/linked-list-01.jpg" alt="linked-list-01.jpg" />
</p>
<pre class="example">
表头为空，表头的后继节点是"节点10"，"节点10"的后继节点是"节点20"。

</pre>
<p>
<b>删除节点</b>
<img src="{{site.url}}/assets/images/linked-list-02.jpg" alt="linked-list-02.jpg" />
<b>添加节点</b>
<img src="{{site.url}}/assets/images/linked-list-03.jpg" alt="linked-list-03.jpg" />
</p></li>
<li>单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</li>
</ul></li>
<li>双链表：它也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。
<ul class="org-ul">
<li><p>
双链表操作图示
<img src="{{site.url}}/assets/images/linked-list-04.jpg" alt="linked-list-04.jpg" />
</p>
<pre class="example">
表头为空，表头的后继节点为"节点10"(数据为10的节点)；"节点10"的后继节点是"节点20"(数据为10的节点)，"节点20"的前继节点是"节点10"；"节点20"的后继节点是"节点30"，"节点30"的前继节点是"节点20"；...；末尾节点的后继节点是表头。

</pre>
<p>
<b>删除节点</b>
<img src="{{site.url}}/assets/images/linked-list-05.jpg" alt="linked-list-05.jpg" />
<b>添加节点</b>
<img src="{{site.url}}/assets/images/linked-list-06.jpg" alt="linked-list-06.jpg" />
</p></li>
<li>代码实现
<ul class="org-ul">
<li><p>
Java
</p>
<div class="org-src-container">
<pre class="src src-java" id="org2143beb"><span style="color: #8b2252;">/**</span>
<span style="color: #8b2252;"> * Java &#23454;&#29616;&#30340;&#21452;&#21521;&#38142;&#34920;&#12290; </span>
<span style="color: #8b2252;"> * &#27880;&#65306;java&#33258;&#24102;&#30340;&#38598;&#21512;&#21253;&#20013;&#26377;&#23454;&#29616;&#21452;&#21521;&#38142;&#34920;&#65292;&#36335;&#24452;&#26159;:java.util.LinkedList</span>
<span style="color: #8b2252;"> */</span>
<span style="color: #a020f0;">public</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">DoubleLink</span>&lt;<span style="color: #228b22;">T</span>&gt;
</pre>
</div></li>
</ul></li>
</ul></li>
<li>循环链表
<ul class="org-ul">
<li>单循环链表</li>
<li>双循环链表</li>
</ul></li>
</ul></li>
</ul></li>
<li>栈（stack）：是计算机科学中一种特殊的串列形式的抽象数据类型，按照后进先出（LIFO, Last In First Out）的原理运作。其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。</li>
<li>队列：又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</li>
<li>数组：在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。
<img src="{{site.url}}/assets/images/array-data-structure-01.jpg" alt="array-data-structure-01.jpg" />
<ul class="org-ul">
<li>数组的特点是：数据的元素在上下界内是连续的；随机访问速度快。</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2bd4e84" class="outline-2">
<h2 id="org2bd4e84"><span class="section-number-2">3</span> 树</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org06e5215" class="outline-3">
<h3 id="org06e5215"><span class="section-number-3">3.1</span> 二叉树</h3>
</div>
<div id="outline-container-org3ef6b0f" class="outline-3">
<h3 id="org3ef6b0f"><span class="section-number-3">3.2</span> AVL 树</h3>
</div>
<div id="outline-container-orgd990957" class="outline-3">
<h3 id="orgd990957"><span class="section-number-3">3.3</span> 伸展树</h3>
</div>
<div id="outline-container-orgda603d6" class="outline-3">
<h3 id="orgda603d6"><span class="section-number-3">3.4</span> 红黑树</h3>
</div>
<div id="outline-container-org2bb4c8e" class="outline-3">
<h3 id="org2bb4c8e"><span class="section-number-3">3.5</span> 哈夫曼树</h3>
</div>
</div>
<div id="outline-container-orgff0b7bb" class="outline-2">
<h2 id="orgff0b7bb"><span class="section-number-2">4</span> 堆</h2>
</div>
<div id="outline-container-org4c6d1ab" class="outline-2">
<h2 id="org4c6d1ab"><span class="section-number-2">5</span> 图</h2>
</div>
<div id="outline-container-org56b2bd9" class="outline-2">
<h2 id="org56b2bd9"><span class="section-number-2">6</span> 排序算法</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgcefe19c" class="outline-3">
<h3 id="orgcefe19c"><span class="section-number-3">6.1</span> 冒泡排序(BubbleSort)</h3>
<div class="outline-text-3" id="text-6-1">
</div>
<div id="outline-container-org096ded8" class="outline-4">
<h4 id="org096ded8"><span class="section-number-4">6.1.1</span> 介绍(Introduction)</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
<b>en</b>
</p>
<pre class="example">
Bubblesort is a popular,but inefficient,sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order.

</pre>
<p>
<b>cn</b>
</p>
<pre class="example">
冒泡排序是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，
则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复
此操作，直到整个数列都有序为止！

</pre>
</div>
</div>
<div id="outline-container-org194b53c" class="outline-4">
<h4 id="org194b53c"><span class="section-number-4">6.1.2</span> 伪代码(pseudo code)</h4>
<div class="outline-text-4" id="text-6-1-2">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>pseudo code</label><pre class="src src-emacs-lisp">for i = 1 to A.length - 1
    for j = A:length downto i + 1
        if A[j] &lt; A[j-1]   
            exchange A[j] with A[j - 1]
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcddfcc4" class="outline-4">
<h4 id="orgcddfcc4"><span class="section-number-4">6.1.3</span> 时间复杂度和稳定性</h4>
<div class="outline-text-4" id="text-6-1-3">
<pre class="example">
冒泡排序的时间复杂度是O(N2)。
假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度是O(N2)。

</pre>

<pre class="example">
冒泡排序是稳定的算法，它满足稳定算法的定义。
算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！

</pre>
</div>
</div>
<div id="outline-container-org61a6412" class="outline-4">
<h4 id="org61a6412"><span class="section-number-4">6.1.4</span> 实现(realization)</h4>
<div class="outline-text-4" id="text-6-1-4">
<p>
<b>C</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>C</label><pre class="src src-C"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>,<span style="color: #a0522d;">j</span>;
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">flag</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26631;&#35760;</span>
<span style="color: #a020f0;">for</span> (i=n-1; i&gt;0; i--)
{
    flag = 0; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#21021;&#22987;&#21270;&#26631;&#35760;&#20026;0</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#23558;a[0...i]&#20013;&#26368;&#22823;&#30340;&#25968;&#25454;&#25918;&#22312;&#26411;&#23614;</span>
    <span style="color: #a020f0;">for</span> (j=0; j&lt;i; j++)
    {
        <span style="color: #a020f0;">if</span> (a[j] &gt; a[j+1])
        {
            swap(a[j], a[j+1]);
            flag = 1;    <span style="color: #b22222;">// </span><span style="color: #b22222;">&#33509;&#21457;&#29983;&#20132;&#25442;&#65292;&#21017;&#35774;&#26631;&#35760;&#20026;1</span>
        }
    }
    <span style="color: #a020f0;">if</span> (flag==0)
        <span style="color: #a020f0;">break</span>;<span style="color: #b22222;">// </span><span style="color: #b22222;">&#33509;&#27809;&#21457;&#29983;&#20132;&#25442;&#65292;&#21017;&#35828;&#26126;&#25968;&#21015;&#24050;&#26377;&#24207;&#12290;</span>
} 
</pre>
</div>

<p>
<b>C#</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>C#</label><pre class="src src-emacs-lisp">//Core code.
for (int i = 0<span style="color: #b22222;">; </span><span style="color: #b22222;">i &lt; arrInt.Length - 1; i++)</span>
{
    for (int j = 1<span style="color: #b22222;">; </span><span style="color: #b22222;">j &lt; arrInt.Length - i; j++)</span>
    {
        if (arrInt[j] &lt; arrInt[j - 1])
        {
            //&#20132;&#25442;&#20540;
            int temp = arrInt[j]<span style="color: #b22222;">;</span>
            arrInt[j] = arrInt[j - 1]<span style="color: #b22222;">;</span>
            arrInt[j - 1] = temp<span style="color: #b22222;">;</span>
        }
    }
}
</pre>
</div>

<p>
<b>Java</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Java</label><pre class="src src-java"><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">BubbleSort</span>(<span style="color: #228b22;">int</span>[] <span style="color: #a0522d;">arr</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">num</span>) {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; arr.<span style="color: #228b22;">length</span>; i++) {
            <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span> = num-1; j &gt;i; j--) {
                    <span style="color: #a020f0;">if</span> (arr[i]&gt;arr[j]) {
                            <span style="color: #228b22;">int</span> <span style="color: #a0522d;">temp</span>=arr[i];
                            arr[i]=arr[j];
                            arr[j]=temp;
                    }
            }
    }
    <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">k</span>=0;k&lt;<span style="color: #228b22;">num</span>;k++){
            System.out.print(arr[k]+<span style="color: #8b2252;">" "</span>);
    }
}
</pre>
</div>

<p>
<b>PHP</b>
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>PHP</label><pre class="src src-shell"><span style="color: #a020f0;">function</span> <span style="color: #0000ff;">BubbleSort</span>($<span style="color: #a0522d;">arr</span>){
        <span style="color: #a020f0;">for</span>($<span style="color: #a0522d;">i</span>=0;$<span style="color: #a0522d;">i</span>&lt;count($<span style="color: #a0522d;">arr</span>);$<span style="color: #a0522d;">i</span>++){
                <span style="color: #a020f0;">for</span>($<span style="color: #a0522d;">j</span>=0;$<span style="color: #a0522d;">j</span>&lt;$<span style="color: #a0522d;">i</span>;$<span style="color: #a0522d;">j</span>++){
                        <span style="color: #a020f0;">if</span>($<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">i</span>]&gt;$<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">j</span>]){
                                $<span style="color: #a0522d;">temp</span> = $<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">i</span>];
                                $<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">i</span>] = $<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">j</span>];
                                $<span style="color: #a0522d;">arr</span>[$<span style="color: #a0522d;">j</span>] = $<span style="color: #a0522d;">temp</span>;
                        }
                }
        }
        foreach($<span style="color: #a0522d;">arr</span> as $<span style="color: #a0522d;">value</span>){
                <span style="color: #483d8b;">echo</span> $<span style="color: #a0522d;">value</span>.<span style="color: #8b2252;">" "</span>;
        }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org990ee9b" class="outline-3">
<h3 id="org990ee9b"><span class="section-number-3">6.2</span> 快速排序(QuickSort)</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-org46c626a" class="outline-4">
<h4 id="org46c626a"><span class="section-number-4">6.2.1</span> 介绍(Introduction)</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
<b>cn</b>
</p>
<pre class="example">
快速排序(Quick Sort)使用分治法策略。
基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外
一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此
达到整个数据变成有序序列。

</pre>

<pre class="example">
快速排序流程：
(1) 从数列中挑出一个基准值。
(2) 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。
(3) 递归地把"基准值前面的子数列"和"基准值后面的子数列"进行排序。

</pre>
</div>
</div>
<div id="outline-container-org4dda56d" class="outline-4">
<h4 id="org4dda56d"><span class="section-number-4">6.2.2</span> 伪代码(pseudo code)</h4>
</div>
<div id="outline-container-orgb9a2afd" class="outline-4">
<h4 id="orgb9a2afd"><span class="section-number-4">6.2.3</span> 时间复杂度和稳定</h4>
<div class="outline-text-4" id="text-6-2-3">
<pre class="example">
快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。 
这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。
(01) 为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。
(02) 为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。

</pre>

<pre class="example">
快速排序是不稳定的算法，它不满足稳定算法的定义。

</pre>
</div>
</div>
<div id="outline-container-orgb97a4f5" class="outline-4">
<h4 id="orgb97a4f5"><span class="section-number-4">6.2.4</span> 实现(realization)</h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
<b>C</b>
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8b2252;">/**</span>
<span style="color: #8b2252;">* arr -- &#24453;&#25490;&#24207;&#30340;&#25968;&#32452;</span>
<span style="color: #8b2252;">* left -- &#25968;&#32452;&#30340;&#24038;&#36793;&#30028;</span>
<span style="color: #8b2252;">* right -- &#25968;&#32452;&#30340;&#21491;&#36793;&#30028;</span>
<span style="color: #8b2252;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">quick_sort</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">arr</span>[],<span style="color: #228b22;">int</span> <span style="color: #a0522d;">left</span>,<span style="color: #228b22;">int</span> <span style="color: #a0522d;">right</span>){
    <span style="color: #a020f0;">if</span>(left &lt; right){
            <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>,<span style="color: #a0522d;">j</span>,<span style="color: #a0522d;">k</span>;
            i = left;
            j = right;
            k = arr[i];
            <span style="color: #a020f0;">while</span>(i &lt; j){
                    <span style="color: #a020f0;">while</span>(i &lt; j &amp;&amp; arr[j] &gt; k){
                            j--; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20174;&#21491;&#24448;&#24038;&#25214;&#19968;&#20010;&#23567;&#20110; k &#30340;&#25968;</span>
                    }
                    <span style="color: #a020f0;">if</span>(i &lt; j){
                            arr[i++] = arr[j];
                    }
                    <span style="color: #a020f0;">while</span>(i&lt;j &amp;&amp; arr[i] &lt; k){
                            i++; <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20174;&#24038;&#24448;&#21491;&#25214;&#31532;&#19968;&#20010;&#22823;&#20110; k &#30340;&#25968;</span>
                    }
            }
            arr[i] = k;
            quick_sort(arr,left,i-1);
            quick_sort(arr,i+1,right);
    }
}
</pre>
</div>
<p>
<b>Java</b>
</p>
<div class="org-src-container">
<pre class="src src-java">
</pre>
</div>
<p>
<b>PHP</b>
</p>
<div class="org-src-container">
<pre class="src src-shell">
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc6f1d46" class="outline-3">
<h3 id="orgc6f1d46"><span class="section-number-3">6.3</span> 插入排序(InsertSort)</h3>
<div class="outline-text-3" id="text-6-3">
</div>
<div id="outline-container-org38241d9" class="outline-4">
<h4 id="org38241d9"><span class="section-number-4">6.3.1</span> 介绍(Instoduction)</h4>
</div>
<div id="outline-container-org97b7018" class="outline-4">
<h4 id="org97b7018"><span class="section-number-4">6.3.2</span> 伪代码(pseudo code)</h4>
<div class="outline-text-4" id="text-6-3-2">
<div class="org-src-container">
<pre class="src src-emacs-lisp">for j=2 to A.length
    key=A[j]<span style="color: #b22222;">;</span>
    //Insert A[j] into the sorted sequence A[1..j-1]
    i=j-1
    while i&gt;0 and A[i]&gt;key
         A[i+1]=A[i]
         i=i-1
    A[i+1]=key
</pre>
</div>
</div>
</div>
<div id="outline-container-org1c8a4a9" class="outline-4">
<h4 id="org1c8a4a9"><span class="section-number-4">6.3.3</span> 实现(realization)</h4>
<div class="outline-text-4" id="text-6-3-3">
<pre class="example">

</pre>
</div>
</div>
<div id="outline-container-org25d8612" class="outline-4">
<h4 id="org25d8612"><span class="section-number-4">6.3.4</span> 分而治之(divideand-conquer)</h4>
<div class="outline-text-4" id="text-6-3-4">
<div class="org-src-container">
<pre class="src src-emacs-lisp">
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6f0580e" class="outline-3">
<h3 id="org6f0580e"><span class="section-number-3">6.4</span> 选择排序</h3>
</div>
<div id="outline-container-org7c1f656" class="outline-3">
<h3 id="org7c1f656"><span class="section-number-3">6.5</span> 希尔排序</h3>
</div>
<div id="outline-container-org3d18b33" class="outline-3">
<h3 id="org3d18b33"><span class="section-number-3">6.6</span> 归并排序</h3>
</div>
<div id="outline-container-orgaca642c" class="outline-3">
<h3 id="orgaca642c"><span class="section-number-3">6.7</span> 基数排序</h3>
</div>
<div id="outline-container-org84db922" class="outline-3">
<h3 id="org84db922"><span class="section-number-3">6.8</span> 堆排序</h3>
</div>
</div>
<div id="outline-container-orgd236f19" class="outline-2">
<h2 id="orgd236f19"><span class="section-number-2">7</span> 参考资料</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表-维基百科</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3603935.html">数据结构与算法系列 目录</a></li>
</ul>
</div>
</div>
