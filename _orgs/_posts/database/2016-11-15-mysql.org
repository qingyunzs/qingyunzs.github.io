#+TITLE:     MySQL Notes
#+AUTHOR:    Zhao Rengui
#+EMAIL:     zrg1390556487@gmail.com
#+LANGUAGE:  cn
#+OPTIONS:   H:6 num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:plain toc:t ltoc:t mouse:underline buttons:0 path:http://202.203.132.245/~20121156044/.org-info.js />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://202.203.132.245/~20121156044/.org-manual.css" />
#+STYLE: <style>body {font-size:14pt} code {font-weight:bold;font-size:100%; color:darkblue}</style>
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:

#+BEGIN_EXPORT HTML
---
layout: post
title: MySQL Notes
author: zrg
comments: false
description: MySQL 命令、配置/优化
categories:
- database
tags:
- MySQL
photos:
---
#+END_EXPORT

# (setq org-export-html-use-infojs nil)
# (setq org-export-html-style nil)

* MySQL 概述
** 什么是 SQL
** 什么是 MySQL
* MySQL 基本操作
** 创建数据库
   #+BEGIN_SRC sql
     -- Create database
     create database dbname;

     -- delete database
     drop database dbname;
   #+END_SRC
** 创建数据表
   #+BEGIN_SRC sql
    -- Create table
    create table TableName(
	   id int(10) not null primary key auto_increment,
	   name varchar(20) not null,
	   password varchar(45) not null,
	   sex int(4) not null default '0',
    );

    -- Alter table
    alter table TableName
    characiter set=utf8mb4,
    collate=utf8mb4_general_ci
   #+END_SRC

** 数据操作
*** SELECT 语句
**** LIMIT 子句
**** ORDER BY 子句
**** WHERE 子句
***** AND & OR 操作符
***** IN 操作符
***** NOT 操作符
***** LIKE 操作符
      1. 百分号 % 通配符
      2. 下划线 _ 通配符
***** 正则表达式(Regular Expression)
      #+BEGIN_SRC sql
    -- Find all data of containing 'mar' string in the name field
    select name from person where name regexp 'mar'
    -- Find all data in the name field that starts with a vowel character or ends with a string of 'ok'
    select name from person where name regexp '^[aeiou]|ok$'
      #+END_SRC
**** GROUP BY 子句和 HAVING 子句
**** 子查询
**** 关联查询
**** 组合查询
*** 数据处理函数
**** 文本处理函数
**** 日期和时间处理函数
**** 数值处理函数
**** 聚合函数
*** 全文搜索
*** INSERT 语句
*** UPDATE 语句
*** DELETE 语句
* MySQL 高级特性 
** 视图
** 存储过程
** 游标
** 触发器
** 事务处理
*** 事务的四大特性
*** 锁
** 访问控制和用户管理
* 性能优化
** 索引
*** 为什么要用索引
*** 索引底层算法：B+ Tree
** MySQL 配置参数
*** 连接请求的变量
**** max_connections
     最大连接数。
     \\
     数值过小会经常出现ERROR 1040: Too many connections错误，可以通过 'conn%' 通配符查看当前状态的连接数量，以定夺该值的大小。
     #+begin_src sql
       show variables like 'max_connections'
       show status like ‘max_used_connections’ -- 响应的连接数
     #+end_src
     
     max_used_connections / max_connections * 100% （理想值≈85%），如果 max_used_connections 与 max_connections 相同，那么就是 max_connections 设置过低或者超过服务器负载上限了，低于10%则设置过大。
**** back_log
     MySQL 能暂存的连接数量。用以当主要的MySQL线程在一个很短时间内得到非常多的连接请求时。
     \\
     如果 MySQL 的连接数据达到 max_connections 时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，如果等待连接的数量超过 back_log，将不被授予连接资源。
     \\
     注1：当观察你主机进程列表（mysql> show full processlist），发现大量 264084 | unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时，就要加大back_log 的值了。
     \\
     注2：默认数值是 50，可调优为 128，对于Linux系统设置范围为小于 512 的整数。
**** interactive_timeout
     一个交互连接在被服务器在关闭前等待行动的秒数。默认数值是 28800，可调优为 7200。
*** 缓冲区变量
**** key_buffer_size
     索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。
     \\
     通过检查状态值 Key_read_requests 和 Key_reads，可以知道 key_buffer_size 设置是否合理。比例 key_reads / key_read_requests 应该尽可能的低，至少是 1:100，1:1000 更好（上述状态值可以使用 SHOW STATUS LIKE 'key_read%' 获得）。
     \\
     key_buffer_size 只对 MyISAM 表起作用。即使你不使用 MyISAM 表，但是内部的临时磁盘表是 MyISAM 表，也要使用该值。可以使用检查状态值 created_tmp_disk_tables 得知详情。
**** query_cache_size
     查询缓冲大小，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。
     \\
     通过检查状态值 Qcache_*，可以知道 query_cache_size 设置是否合理（上述状态值可以使用 SHOW STATUS LIKE 'Qcache%' 获得）。如果 Qcache_lowmem_prunes 的值非常大，则表明经常出现缓冲不够的情况，如果 Qcache_hits 的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果 Qcache_hits 的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在 SELECT 语句中加入 SQL_NO_CACHE 可以明确表示不使用查询缓冲。
     \\
     与查询缓冲有关的参数还有：
     | 参数                     | 描述                                                                                                                                                                                                    |
     |--------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     | query_cache_type         | 指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。                                                                                                                                      |
     |--------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     | query_cache_limit        | 指定单个查询能够使用的缓冲区大小，缺省为1M。                                                                                                                                                            |
     |--------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     | query_cache_min_res_unit | 是在4.1版本以后引入的，它指定分配缓冲区空间的最小单位，缺省为4K。检查状态值Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小query_cache_min_res_unit。 |
     |--------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     #+begin_src sql
       show global status like 'qcache%';
       show variables like ‘query_cache%‘;
     #+end_src

     - 查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100% 。如果查询缓存碎片率超过 20%，可以用 FLUSH QUERY CACHE 整理缓存碎片，或者试试减小 query_cache_min_res_unit，如果你的查询都是小数据量的话。
     - 查询缓存利用率= (query_cache_size – Qcache_free_memory) / query_cache_size * 100%。查询缓存利用率在 25% 以下的话说明 query_cache_size 设置的过大，可适当减小；查询缓存利用率在 80％ 以上而且 Qcache_lowmem_prunes > 50 的话说明 query_cache_size 可能有点小，要不就是碎片太多。
     - 查询缓存命中率= (Qcache_hits – Qcache_inserts) / Qcache_hits * 100%。
     
     \\
     *关于 query_cache_type=OPTION：*
     : Set the query cache type. Possible options are as follows:
     : 0 : Don't cache results in or retrieve results from the query cache.
     : 1 : Cache all query results except for those that begin with SELECT S_NO_CACHE.
     : 2 : Cache results only for queries that begin with SELECT SQL_CACHE
**** record_buffer_size
     每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。
     \\
     默认数值是 131072(128K)，可改为 16773120 (16M)
**** read_rnd_buffer_size
     随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL 会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但 MySQL 会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M。
**** sort_buffer_size
     每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。
     \\
     默认数值是2097144(2M)，可改为16777208 (16M)。
**** join_buffer_size
     联合查询操作所能使用的缓冲区大小。
     \\
     record_buffer_size，read_rnd_buffer_size，sort_buffer_size，join_buffer_size为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100
**** table_cache
     表高速缓存的大小。
     \\
     通过检查峰值时间的状态值 Open_tables 和 Opened_tables，可以决定是否需要增加 table_cache 的值。如果你发现 open_tables 等于 table_cache，并且 opened_tables 在不断增长，那么你就需要增加 table_cache 的值了（上述状态值可以使用 SHOW STATUS LIKE 'Open%tables' 获得）。注意，不能盲目地把 table_cache 设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。
     \\
     1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。
**** max_heap_table_size
     用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=#
     \\
     这个变量和 tmp_table_size 一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过 tmp_table_size，MySQL 可以根据需要自动将内存中的 heap 表改为基于硬盘的 MyISAM 表。
**** tmp_table_size
     通过设置 tmp_table_size 选项来增加一张临时表的大小，例如做高级 GROUP BY 操作生成的临时表。如果调高该值，MySQL 同时将增加 heap 表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的 MyISAM 表。
     \\
    可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。
    \\
    通过比较 Connections和Threads_created状态的变量，可以看到这个变量的作用。
    \\
    默认值为110，可调优为80。
**** thread_concurrency
     推荐设置为服务器 CPU 核数的2倍，例如双核的 CPU, 那么 thread_concurrency 的应该为4；2个双核的 cpu, thread_concurrency 的值应为8。默认为8
**** wait_timeout
     指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。
*** 配置InnoDB的几个变量
**** innodb_buffer_pool_size
     对于 InnoDB 表来说，innodb_buffer_pool_size 的作用就相当于 key_buffer_size 对于 MyISAM 表的作用一样。InnoDB 使用该参数指定大小的内存来缓冲数据和索引。对于单独的 MySQL 数据库服务器，最大可以把该值设置成物理内存的 80%。
     \\
     根据 MySQL 手册，对于 2G 内存的机器，推荐值是 1G（50%）。
**** innodb_flush_log_at_trx_commit
     主要控制了 innodb 将 log buffer 中的数据写入日志文件并flush磁盘的时间点，取值分别为 0、1、2 三个。0，表示当事务提交时，不做日志写入操作，而是每秒钟将 log buffer 中的数据写入日志文件并 flush 磁盘一次；1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush 磁盘的操作，确保了事务的 ACID；设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次 flush 磁盘操作。
     \\
     实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入 10000 条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL 手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。
     \\
     根据 MySQL 手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。
**** innodb_log_buffer_size
     log缓存大小，一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。
     \\
     可设置为4M或8M。
**** innodb_additional_mem_pool_size
     该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。
     \\
     根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。
**** innodb_thread_concurrency=8
     推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8
** 操作系统和硬件优化
* 集群
** 复制
** 扩展
** 高可用性
* 数据库维护
** 备份与还原
** 数据库日志
* 实际应用查询
** MySQL 命令
   #+BEGIN_SRC sql
  --显示数据库列表
  >show databases;
  --显示表的列表
  >show tables;
  >show columns from table_name;
  --用以显示服务器状态信息
  >show status;
  >SHOW STATUS LIKE '%变量名% ';
  --显示创建特定数据库或表的MySQL语句
  >show create database;
  >show create table;
  --显示授予用户（所有用户或特定用户）的安全权限
  >show grants;
  --显示错误或警告信息
  >show errors;
  >show warnings;
  --显示系统变量
  >SHOW VARIABLES;

  -- 查看服务器版本信息
  SELECT VERSION()
  -- 当前数据库名 (或者返回空)
  SELECT DATABASE()
  -- 当前用户名
  SELECT USER()
   #+END_SRC
** 以某个字段进行分组查询，每组前n条记录
   #+BEGIN_SRC sql
  select res.* from(
   select * from View_ArticleChannel a
   where a.ID in(
	  select top 3 ID from View_ArticleChannel where a.ChannelName=ChannelName order by a.ChannelName DESC
   )
  ) as res
  where res.ChannelName in('物流公司','云仓公告')
  -- group by res.ID,res.ChannelName,res.Title
  order by res.ChannelName
   #+END_SRC
** 根据当天日期判断使用哪个字段排序
   #+BEGIN_SRC sql
select card_no
from Customer_V_InTruckInfo
where card_no like '%dm16%'
order by (
  case
     when 19%2=0 then name
     else truck_no end
)
-- 如果使用C#代码，19可替换为:"+DateTime.Now.Day+"
   #+END_SRC
** 分组获取记录的第一条数据
   #+BEGIN_SRC sql
select * from(
SELECT   ROW_NUMBER()over(partition by VehicleId order by CreateTime DESC) as RowNumber,ID, VehicleId, VehicleNo, Driver, DriverPhone, ContactType,
                (CASE ContactType WHEN '1' THEN '短信' WHEN '2' THEN '电话' END) AS ContactType_ex, ContactContent, CreateUser,
                CreateTime, ModifyUser, ModifyTime, ContactResult,
                (CASE ContactResult WHEN '1' THEN '有意向' WHEN '2' THEN '无意向' WHEN '3' THEN '停卡' END)
                AS ContactResult_ex, NextContactTime, ContactPersonIdea, IsDelete, ExtendField1, ExtendField2, ExtendField3,
                ExtendField4, ExtendField5
FROM      dbo.VehicleTrackInfo) AS track
where track.RowNumber=1
and track.VehicleId='95654e2ffb134f6581f94aa5ed178529'
   #+END_SRC
** 使用SQL语句清空数据库中所有表的数据
   表非常多,一张一张的清空,实在麻烦,想利用SQL语句一次清空所有数据.找到了三种方法进行清空.使用的数据库为MS SQL SERVER.
*** Method 1:搜索出所有表名,构造为一条SQL语句
    #+BEGIN_SRC sql
declare @trun_name varchar(8000)
set @trun_name=''
select @trun_name=@trun_name + 'truncate table ' + [name] + ' ' from sysobjects where xtype='U' and status > 0
exec (@trun_name)
    #+END_SRC
    该方法适合表不是非常多的情况,否则表数量过多,超过字符串的长度,不能进行完全清理.
*** Method 2:利用游标清理所有表
    #+BEGIN_SRC sql
declare @trun_name varchar(50)
declare name_cursor cursor for
select 'truncate table' + name from sysobjects where xtype='U' and status > 0
open name_cursor
fetch next from name_cursor into @trun_name
while @@FETCH_STATUS = 0
begin
  exec (@trun_name)
  print 'truncated table' + @trun_name
  fetch next from name_cursor into @trun_name
end
close name_cursor
deallocate name_cursor
    #+END_SRC
    可以做为存储过程调用, 能够一次清空所有表的数据,并且还可以进行有选择的清空表.
*** Method 3:利用微软未公开的存储过程
    #+BEGIN_SRC sql
exec sp_msforeachtable "truncate table ?"
    #+END_SRC
    该方法可以一次清空所有表,但不能加过滤条件.
    : 附-删除表：exec sp_msforeachtable 'DROP table ?'
* 参考资料
  + http://www.cnblogs.com/Bozh/archive/2013/01/22/2871545.html
* 附-EXPLAIN
* 附-MySQL 正则模式
  | 模式                 | 描述                                                                                                       |
  |----------------------+------------------------------------------------------------------------------------------------------------|
  | ^                    | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。      |
  | $                    | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。       |
  | .                    | 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。                  |
  | [...]                | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。                             |
  | [^...]               | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。                             |
  | p1 \vert p2 \vert p3 | 匹配 p1 或 p2 或 p3。例如，'z \vert food' 能匹配 "z" 或 "food"。'(z \vert f)ood' 则匹配 "zood" 或 "food"。 |
  | *                    | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。                              |
  | +                    | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。          |
  | {n}	n         | 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。      |
  | {n,m}                | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。                                            |
