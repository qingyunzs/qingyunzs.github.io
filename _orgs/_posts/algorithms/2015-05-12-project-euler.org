#+TITLE:     Project Euler(欧拉计划)
#+AUTHOR:    zrg
#+EMAIL:     zrg1390556487@gmail.com
#+LANGUAGE:  cn
#+OPTIONS:   H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:plain toc:t ltoc:t mouse:underline buttons:0 path:http://cs3.swfc.edu.cn/~20121156044/.org-info.js />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://cs3.swfu.edu.cn/~20121156044/.org-manual.css" />
#+HTML_HEAD_EXTRA: <style>body {font-size:16pt} code {font-weight:bold;font-size:100%; color:darkblue}</style>
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT: 

#+BEGIN_EXPORT HTML
---
layout: post
title: Project Euler
author: zrg
comments: false
description: 欧拉计划是一系列有挑战性的数学与计算机编程题；要解开它们，需要的不止是数学知识：尽管数学能够帮助你找到一些优雅而有效的方法，大多数题目仍需要借助计算机和编程技巧来完成解答。
categories:
- algorithms
tags:
- 欧拉计划
photos:
---
#+END_EXPORT

# (setq org-export-html-use-infojs nil)
# (setq org-export-html-style nil)

* Preface
: Official Site: https://pe-cn.github.io/
* 1~100
** Multiples of 3 and 5
#+BEGIN_SRC C
/*
Multiples of 3 and 5
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.

3的倍数和5的倍数
如果我们列出10以内所有3或5的倍数，我们将得到3、5、6和9，这些数的和是23。

求1000以内所有3或5的倍数的和。

*/
#include<stdio.h>
int main(){
	int sum=0;
	for(int i=0;i<1000;i++){
		if(i%3 == 0 || i%5 == 0){
			sum+=i;	
		}
	}
	printf("1000以内所有3或5的倍数的和：%d\n",sum);
	return 0;
}

#+END_SRC
** Even Fibonacci numbers
#+BEGIN_SRC C
/*
 * Even Fibonacci numbers
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
 *
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …
 * By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 *
 * 偶斐波那契数
 * 斐波那契数列中的每一项都是前两项的和。由1和2开始生成的斐波那契数列前10项为：
 *
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …
 * 考虑该斐波那契数列中不超过四百万的项，求其中为偶数的项之和。
 * */
#include<stdio.h>
#include<stdlib.h>
int fun_recursive(int n);
int main(){
        int n;
        printf("请输入要输出项（自然数）斐波那契数列：");
        scanf("%d",&n);
        int *a = (int *)malloc((n+1)*sizeof(int));//如需存储，使用动态内存分配n+1个空间进行存储
        int i,sum=0;
        for(i=1;i<n+1;i++){
                int number=fun_recursive(i);
                printf("%d,",number);
                if(i!=0 && i%5==0){
                        printf("\n");
                }
                if(number%2 == 0){
                        //求偶数项之和
                        sum+=number;
                }
        }
        printf("偶数项之和：%d\n",sum);
        return 0;
}
int fun_recursive(int n){
        if(n<=1){
                return n;
        }else{
                return fun_recursive(n-1)+fun_recursive(n-2);
        }
}
#+END_SRC
** Largest prime factor
#+BEGIN_SRC C
/* Largest prime factor
 * The prime factors of 13195 are 5, 7, 13 and 29.
 *
 * What is the largest prime factor of the number 600851475143 ?
 *
 * 最大质因数
 * 13195的所有质因数为5、7、13和29。
 *
 * 600851475143最大的质因数是多少？
 * */
#include<stdio.h>
int main(){
	long int n,i;
	printf("请输入任意正整数：");
	scanf("%ld",&n);
	for(i=2;i<n;i++){
		while(n!=i){
			if(n%i == 0){
				printf("%ld*",i);
				n/=i;
			}else{
				break;
			}
		}
	}
	printf("%ld\n",n);
	return 0;
}
#+END_SRC
** Largest palindrome product
#+NAME: C language
#+BEGIN_SRC C
/* Largest palindrome product
 * A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
 *
 * Find the largest palindrome made from the product of two 3-digit numbers.
 *
 * 最大回文乘积
 * 回文数就是从前往后和从后往前读都一样的数。由两个2位数相乘得到的最大回文乘积是 9009 = 91 × 99。
 *
 * 找出由两个3位数相乘得到的最大回文乘积。
 *
 * */
#include<stdio.h>
char *reverseStr(char *str,size_t len)
int main(){
        int max = 0;
        for(int i=100;i<=999;i++){
                for(int j=100;j<=999;j++){
                        int palindrome = i*j;
                        //字符串反转
                        *reverseStr()
                }
        }
}
char *reverseStr(char *str, size_t len){
        char *start = str;
        char *end = str+len-1;
        char ch;
        if(str != NULL){
                while(start<end){
                        ch = *start;
                        *start++=*end;
                        *end-- =ch;
                }
        }
        return str;
}
#+END_SRC
#+NAME: Python language
#+BEGIN_SRC Python
# coding:utf-8
# Largest palindrome product
# A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
#
# Find the largest palindrome made from the product of two 3-digit numbers.
#
# 最大回文乘积
# 回文数就是从前往后和从后往前读都一样的数。由两个2位数相乘得到的最大回文乘积是 9009 = 91 × 99。
#
# 找出由两个3位数相乘得到的最大回文乘积。
# 
#
# 定义字符反转方法
def reverse(num):
    strnum = str(num)[::-1]
    return int(strnum)
max = None
for a in range(100,1000):
    for b in range(100,1000):
        rs=a*b
        if(rs == reverse(rs) and rs > max):
            max=rs;
print '由两个3位数相乘得到的最大回文乘积是：',max
#+END_SRC
** Smallest multiple
#+NAME: C language
#+BEGIN_SRC C
/* Smallest multiple
 * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
 *
 * What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
 *
 * 最小倍数
 * 2520是最小的能够被1到10整除的数。
 *
 * 最小的能够被1到20整除的正数是多少？
 * */
#include<stdio.h>
#+END_SRC
* 101~200
* 201~300
* 301~400
* 401~500
* 501~600
* 601~now
